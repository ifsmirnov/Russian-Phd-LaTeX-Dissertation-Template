\begin{theorem}[о корректности и асимптотике {\CH[r]}] \label{th:fast-correct-r}
Для любого натурального $r > 1$, для любой последовательности из
$n$ операций \textbf{insert} и $k$ операций \textbf{extractMin},
в которой запрос \textbf{extractMin} может поступать только к непустой
куче, верно следующее:
\begin{enumerate}
\item (корректность) каждая операция \textbf{extractMin} удаляет минимальный элемент
из находящихся в куче к тому моменту;
\item (асимптотика) каждая операция \textbf{insert} требует $O(r)$ сравнений,
каждая операция \textbf{extractMin} требует $O(\log^{(r)} n + r(\log k + \log r))$ сравнений,
где $k$ "--- количество вызовов \textbf{extractMin} к тому моменту, причём
обе оценки верны в худшем случае.
\end{enumerate}
\end{theorem}

\begin{theorem}[о корректности и асимптотике {\CH[*]}] \label{th:fast-correct-*}
Для любой последовательности из
$n$ операций \textbf{insert} и $k$ операций \textbf{extractMin},
в которой запрос \textbf{extractMin} может поступать только к непустой
куче, верно следующее:
\begin{enumerate}
\item (корректность) каждая операция \textbf{extractMin} удаляет минимальный элемент
из находящихся в куче к тому моменту;
\item (асимптотика) каждая операция \textbf{insert} требует $O(\log^* n)$ сравнений,
каждая операция \textbf{extractMin} требует $O(\log^* n(\log k + \log \log^* n))$ сравнений,
где $k$ "--- количество вызовов \textbf{extractMin} к тому моменту, причём
обе оценки верны в худшем случае.
\end{enumerate}
\end{theorem}

\bigskip

Как и в секции \ref{ch:proof-simple}, для доказательства этих двух теорем
будет сформулировано и доказано несколько лемм. Если явно не сказано иное,
каждая лемма относится как и к \CH[r], так и к \CH[*]. Все леммы и теоремы,
в которых фигурирует буфер, относятся только к \CH[r]. Во всех доказательствах
параметр $r$ считается произвольным положительным натуральным числом.

\begin{remark}
Если явно не сказано иное, под записью $\log x$ подразумевается
двоичный логарифм ($\log_2 x$). То же самое относится к повторному
логарифму ($\log^{(r)} x$) и к итеративному ($\log^* x$).
\end{remark}

\begin{lem} \label{th:mh-few-elements}
Пусть в \MH[t] для некоторого $t$ переполнилась в некоторый
момент времени. Тогда для любого $b \geq 0$ после $b$
вставок $|\MH[t]| \leq b + 1$.
\end{lem}
\begin{proof}
Сначала заметим, что операция \textbf{extractMin}
может только уменьшить
количество элементов в \MH[t].

Элементы могут попасть в \MH[t] двумя способами:
\begin{enumerate}
\item в результате переполнения \MH[t] в неё попадает
куча, отложенно вставляемая в \MH[t];
\item в \MH[t] добавляется новый элемент в результате
завершившейся балансировки на уровне $t-1$.
\end{enumerate}

После события первого типа $|\MH[t]| = 1$. Событие второго
типа может произойти не чаще, чем один раз на вставку, потому
что две балансировки не могут идти одновременно.
Значит, при увеличении $b$ на $1$
в \MH[t] попадает не более одного элемента, что и доказывает
лемму.
\end{proof}

\begin{lem} \label{th:mh-exp-growth}
Пусть на $t$-м уровне ($t \geq 0$, в случае \CH[*] $t > 0$)
произошло переполнение кучи \MH[t] или буфера
после $n$ вставок, и следующее переполнение на этом уровне
произойдёт после $n' = n + b$ вставок для некоторого $b$,
если за это время не произойдёт вызова \textbf{extractMin}.
Тогда $|\MH[t+1]| \leq 2^b$.
\end{lem}
\begin{proof}[Доказательство для {\CH[r]}]\belowdisplayskip=-14pt
Обозначим $s = \log^{(r-t+1)} n$. Из условий на переполнение имеем:
\begin{gather*}
b > \log^{(r-t)} (n + b) \mathrm{\quad по\ лемме\ \ref{th:mh-few-elements}} \\
b > \log^{(r-t)} n = \log s \\
2^b > s \\
|\MH[t+1]| \leq \log^{(r+t-1)} n = s \mathrm{\quad из\ условий\ переполнения} \\
|\MH[t+1]| < 2^b
\end{gather*}
\end{proof}

\begin{proof}[Доказательство для {\CH[*]}]\belowdisplayskip=-14pt
\begin{gather*}
b \geq {}^t 2 \mathrm{\quad по\ лемме\ \ref{th:mh-few-elements}} \\
2^b \geq {}^{t+1} 2 \\
|\MH[t+1]| \leq {}^{t+1} 2\mathrm{\quad из\ условий\ переполнения} \\
|\MH[t+1]| \leq 2^b
\end{gather*}
\end{proof}


\begin{lem} \label{th:bal-constant}
Пусть на $t$-м уровне ($t \geq 0$, в случае \CH[*] $t > 0$)
произошло переполнение кучи \MH[t] или буфера
после $n$ вставок, и следующее переполнение на этом уровне
произойдёт после $n' = n + b$ вставок для некоторого $b$,
если за это время не произойдёт вызова \textbf{extractMin}.
Тогда найдётся константа $C$ такая, что балансировку можно
выполнить за не более чем $C \cdot b$ сравнений в худшем случае.
\end{lem}
\begin{proof}
Балансировка может состоять из не более чем двух стадий:
построение кучи на элементах буфера и вставка в промежуточную
кучу следующего уровня.

Рассмотрим первую стадию. Пусть размер буфера при переполнении
равен $s$. Тогда $s \leq b$ в силу монотонности повторного логарифма.
На $s$ элементах можно построить бинарную кучу за $O(s) \in O(b)$ сравнений
согласно~\cite[с.~181]{Cormen}.

Рассмотрим вторую стадию. Из леммы \ref{th:mh-exp-growth}
известно, что $|\MH[t]| \leq 2^b$. Вставку реализуется
за $O(|\MH[t]|)$ сравнений, что есть $O(b)$.

Обе части балансировки реализуются за $O(b)$ сравнений. Значит,
вся балансировка на отдельно взятом уровне реализуется за $O(b)$
сравнений, и существование искомой константы следует из определения
<<$O$~большого>>.
\end{proof}

\begin{lem} \label{th:one-balancing}
На каждом уровне одновременно не может идти более чем одна балансировка.
\end{lem}
\begin{proof}
Во время каждой операции \textbf{insert} на каждом уровне проделывается
$C$ шагов балансировки, где $C$ "--- константа из леммы \ref{th:bal-constant}.
Но эта константа определена так, чтобы балансировка успела завершиться
за $b$ шагов, где $b$ "--- минимально возможное количество вставок
до начала следующей балансировки.
\end{proof}

\begin{lem} \label{th:log*-levels}
Количество уровней в \CH[*] (т.~е. \textsf{MaximumLevel}) не превосходит
$\log^* n + 1$.
\end{lem}
\begin{proof}
Из условий на переполнение следует, что если $\mathsf{MaximumLevel} = t$,
то $n \geq {}^{t-1}2$. Значит, $\log^* n \geq t-1$, то есть
$t \leq \log^* n + 1$.
\end{proof}


\begin{lem} \label{th:small-mh-level}
Для любого валидного $t > 0$ верно
$\lev(\MH[t]) \leq t + 1$.
\end{lem}
\begin{proof}
Докажем индукцией по $t$.

Если $t=1$, то все элементы \MH[t] "--- кучи (уровня 1), построенные на элементах буфера
(в случае \CH[r]) или единичные элементы (в случае \CH[*]). В обоих случаях $\lev \MH[1] \leq 2$.

Если $t > 1$, то все элементы \MH[t] имеют уровень, не превосходящий максимальный уровень
\MH[t-1]. Тогда из предположения индукции получаем, что $\lev(\MH[t]) \leq \lev(\MH[t-1]) + 1 \leq t+1$.
\end{proof}


\begin{lem} \label{th:small-hh-level}
Положим
\[
R = \begin{cases}
r \mathrm{\ в\ случае\ \CH[r]} \\
\mathsf{MaximumLevel} \mathrm{\ в\ случае\ \CH[*]}
\end{cases}.
\]
Тогда $\lev(\HH) \leq R + 2$.
\end{lem}
\begin{proof}
Все элементы, попадающие в \HH, попадают туда из какой-то \MH[t]
или из кучи, которая когда-то была одной из \MH[t]. По построению
$t \leq R$. Из теоремы~\ref{th:small-mh-level} уровень добавляемого
элемента не превосходит $R+1$. Но тогда $\lev(\HH) \leq R+2$.
\end{proof}

\begin{theorem}[о сохранении инвариантов] \label{th:invar}
В любой момент сохраняются следующие инварианты:
\begin{enumerate}
\item \MH[t] и все её элементы "--- корректные бинарные кучи для любого валидного $t$;
\item \HH и все её элементы "--- корректные бинарные кучи;
\item Если балансировка на $t$-м уровне находится в стадии II, то множество \T{t}, которое
вставляется в \MH[t+1] "--- корректная бинарная куча;
\item[4r.] (версия {\CH[r]})\quad $|\HH| \leq (4r+4)k$;
\item[4*.] (версия {\CH[*]})\quad $|\HH| \leq k\cdot (4 \log^* n + 8)$.
\addtocounter{enumi}{-1}
\end{enumerate}
\end{theorem}
\begin{proof}
Доказательство этой теоремы техническое и построено так же, как и
доказательство теоремы~\ref{theo-invariant}.

При инициализации, когда структура пуста, все инварианты выполнены. Докажем,
что они выполняются после всех операций.

При выполнении операции \textbf{insert} происходит две вещи: непосредственно добавление
элемента в буфер или \MH[1] и, возможно, несколько операций по балансировке. Добавление
в буфер не затрагивает ни одно из интересующих нас множеств. Добавление в \MH[1]
происходит только в \CH[*]. Поскольку в ней нет нулевого уровня балансировки,
на инвариант (3) вставка не влияет. Инвариант (1) сохраняется по свойству вставки в кучу.

Посмотрим на балансировку.

При выполнении первой стадии балансировки, опять же, ни одно из интересующих
нас множеств не изменяется. К моменту завершения первой стадии множество
\T{0} представляет собой бинарную кучу согласно алгоритму \ref{alg:insert-r}
и в дальнейшем не изменяется до окончания балансировки. Значит, инвариант
(3) выполнен.

При выполнении второй стадии балансировки изменяется только <<будущая>>
версия \MH. К моменту завершения второй стадии <<будущая>> версия является
корректной кучей согласно алгоритмам \ref{alg:insert-r} и \ref{alg:insert-*},
кроме того, вставляемый элемент является корректной кучей по инварианту (3). Значит,
инвариант (1) сохранится во время второй стадии балансировки и её завершения.

Операцию \textbf{extractMin} можно разбить на две части: завершение балансировки
и непосредственно извлечение минимального элемента. Проведение первой стадии
балансировки не нарушает инварианты, как мы видели ранее. Для завершения
второй стадии необходимо добавить все множества \T{t} и \MH[t] в \HH; все они
являются корректными кучами по инвариантам (1) и (3). Таким образом, мы не нарушим
инвариант (2).

Посчитаем, сколько элементов было добавлено в \HH. Для каждого уровня $t$ могло
быть добавлено не более двух новых элементов (\MH[t] и \T{t}).
Значит, в \CH[r] было добавлено не более $2r$ элементов, в \CH[*] "---
не более $2(\log^* n+1)$ (теор.~\ref{th:log*-levels}).

Если извлечение минимума произошло из буфера, инварианты не нарушаются. Если
извлечение произошло из \HH, то, исходя из операции \Yield, в \HH
добавилось не более $2 \cdot \lev \left(\HH.\mathbf{top}()\right) \leq \lev(\HH)$ элементов. Кроме того,
все добавленные элементы "--- корректные бинарные кучи. Значит, инвариант (2)
выполнен.

В случае \CH[r] за одну операцию удаления в \HH было добавлено не более
$2r + 2\lev(\HH) \leq 2r + 2(r+2) = 4r+4$ элементов.

В случае \CH[*] в \HH было добавлено не более
$2(\log^*n + 1) + 2\lev(\HH) \leq 2(\log^*n+1) + 2(\log^*n+3)
= 4 \log^*n + 8$ элементов. Кроме того, $\log^*n$ монотонно неубывает
по $n$. Это доказывает соблюдение инвариантов (4r) и (4*).
В этих утверждениях мы использовали теорему~\ref{th:small-hh-level}.
\end{proof}

\begin{proof}[Доказательство теорем~\ref{th:fast-correct-r} и~\ref{th:fast-correct-*}]
Доказательство этих теорем напрямую следует из теоремы~\ref{th:invar}
о сохранении инвариантов и леммы~\ref{th:one-balancing}.
\end{proof}

Наконец, докажем теоретическую нижнюю оценку.

\begin{theorem} \label{th:lower_bound}
Пусть некоторая структура данных реализует операции \textbf{insert} и
\textbf{extractMin}, причём операция \textbf{insert} требует $O(1)$ сравнений
в худшем случае. Тогда для выполнения $k$ операций \textbf{extractMin}
требуется $\Omega(k \log k)$ сравнений в худшем случае.
\end{theorem}
\begin{proof}
Заметим, что выполнить $k$ извлечений минимума может оказаться не проще,
чем отсортировать $k$ элементов. Из теоретико-информационных соображений
известно, что на это требуется $\Theta(k \log k)$ сравнений\cite[с.~222]{Cormen}.

На все операции вставки было потрачено $O(n)$ сравнений.
Тогда при $k = \omega(\frac{n}{\log n})$ имеем $\Theta(k \log k) \notin O(n)$,
то есть сравнений, получаемых от добавления элементов, недостаточно
для проведения сортировки. Значит, в худшем случае
требуется $\Omega(k \log k)$ дополнительных сравнений.
\end{proof}
