\begin{theorem}[о корректности и асимптотике {\CH[r]}] \label{th:fast-correct-r}
Для любого натурального $r > 1$, для любой последовательности из
$n$ операций \textbf{insert} и $k$ операций \textbf{extractMin},
в которой запрос \textbf{extractMin} может поступать только к непустой
куче, верно следующее:
\begin{enumerate}
\item (корректность) каждая операция \textbf{extractMin} удаляет минимальный элемент
из находящихся в куче к тому моменту;
\item (асимптотика) каждая операция \textbf{insert} требует $O(r)$ сравнений,
каждая операция \textbf{extractMin} требует $O(\log^{(r)} n + r(\log k + \log r))$ сравнений,
где $k$ "--- количество вызовов \textbf{extractMin} к тому моменту, причём
обе оценки верны в худшем случае.
\end{enumerate}
\end{theorem}

\begin{theorem}[о корректности и асимптотике {\CH[*]}] \label{th:fast-correct-*}
Для любой последовательности из
$n$ операций \textbf{insert} и $k$ операций \textbf{extractMin},
в которой запрос \textbf{extractMin} может поступать только к непустой
куче, верно следующее:
\begin{enumerate}
\item (корректность) каждая операция \textbf{extractMin} удаляет минимальный элемент
из находящихся в куче к тому моменту;
\item (асимптотика) каждая операция \textbf{insert} требует $O(\log^* n)$ сравнений,
каждая операция \textbf{extractMin} требует $O(\log^* n(\log k + \log \log^* n))$ сравнений,
где $k$ "--- количество вызовов \textbf{extractMin} к тому моменту, причём
обе оценки верны в худшем случае.
\end{enumerate}
\end{theorem}

\bigskip

Как и в секции \ref{ch:proof-simple}, для доказательства этих двух теорем
будет сформулировано и доказано несколько лемм. Если явно не сказано иное,
каждая лемма относится как и к \CH[r], так и к \CH[*]. Все леммы и теоремы,
в которых фигурирует буфер, относятся только к \CH[r]. Во всех доказательствах
параметр $r$ считается произвольным положительным натуральным числом.

\begin{remark}
Если явно не сказано иное, под записью $\log x$ подразумевается
двоичный логарифм ($\log_2 x$). То же самое относится к повторному
логарифму ($\log^{(r)} x$) и к итеративному ($\log^* x$).
\end{remark}

\begin{lem} \label{th:mh-few-elements}
Пусть в \MH[t] для некоторого $t$ переполнилась в некоторый
момент времени. Тогда для любого $b \geq 0$ после $b$
вставок $|\MH[t]| \leq b + 1$.
\end{lem}
\begin{proof}
Сначала заметим, что операция \textbf{extractMin}
может только уменьшить
количество элементов в \MH[t].

Элементы могут попасть в \MH[t] двумя способами:
\begin{enumerate}
\item в результате переполнения \MH[t] в неё попадает
куча, отложенно вставляемая в \MH[t];
\item в \MH[t] добавляется новый элемент в результате
завершившейся балансировки на уровне $t-1$.
\end{enumerate}

После события первого типа $|\MH[t]| = 1$. Событие второго
типа может произойти не чаще, чем один раз на вставку, потому
что две балансировки не могут идти одновременно \todo{теорема
об этом, вообще говоря, пользуется этой леммой, так что по-честному
нужна индукция по уровню}. Значит, при увеличении $b$ на $1$
в \MH[t] попадает не более одного элемента, что и доказывает
лемму.
\end{proof}

\begin{lem} \label{th:mh-exp-growth}
Пусть на $t$-м уровне ($t \geq 0$, в случае \CH[*] $t > 0$)
произошло переполнение кучи \MH[t] или буфера
после $n$ вставок, и следующее переполнение на этом уровне
произойдёт после $n' = n + b$ вставок для некоторого $b$,
если за это время не произойдёт вызова \textbf{extractMin}.
Тогда $|\MH[t+1]| \leq 2^b$.
\end{lem}
\begin{proof}[Доказательство для {\CH[r]}]\belowdisplayskip=-14pt
Обозначим $s = \log^{(r-t+1)} n$. Из условий на переполнение имеем:
\begin{gather*}
b > \log^{(r-t)} (n + b) \mathrm{\quad по\ лемме\ \ref{th:mh-few-elements}} \\
b > \log^{(r-t)} n = \log s \\
2^b > s \\
|\MH[t+1]| \leq \log^{(r+t-1)} n = s \mathrm{\quad из\ условий\ переполнения} \\
|\MH[t+1]| < 2^b
\end{gather*}
\end{proof}

\begin{proof}[Доказательство для {\CH[*]}]\belowdisplayskip=-14pt
\begin{gather*}
b \geq {}^t 2 \mathrm{\quad по\ лемме\ \ref{th:mh-few-elements}} \\
2^b \geq {}^{t+1} 2 \\
|\MH[t+1]| \leq {}^{t+1} 2\mathrm{\quad из\ условий\ переполнения} \\
|\MH[t+1]| \leq 2^b
\end{gather*}
\end{proof}


\begin{lem} \label{th:bal-constant}
Пусть на $t$-м уровне ($t \geq 0$, в случае \CH[*] $t > 0$)
произошло переполнение кучи \MH[t] или буфера
после $n$ вставок, и следующее переполнение на этом уровне
произойдёт после $n' = n + b$ вставок для некоторого $b$,
если за это время не произойдёт вызова \textbf{extractMin}.
Тогда найдётся константа $C$ такая, что балансировку можно
выполнить за не более чем $C \cdot b$ сравнений в худшем случае.
\end{lem}
\begin{proof}
Балансировка может состоять из не более чем двух стадий:
построение кучи на элементах буфера и вставка в промежуточную
кучу следующего уровня.

Рассмотрим первую стадию. Пусть размер буфера при переполнении
равен $s$. Тогда $s \leq b$ в силу монотонности повторного логарифма.
На $s$ элементах можно построить бинарную кучу за $O(s) \in O(b)$ сравнений
согласно~\cite[с.~181]{Cormen}.

Рассмотрим вторую стадию. Из леммы \ref{th:mh-exp-growth}
известно, что $|\MH[t]| \leq 2^b$. Вставку реализуется
за $O(|\MH[t]|)$ сравнений, что есть $O(b)$.

Обе части балансировки реализуются за $O(b)$ сравнений. Значит,
вся балансировка на отдельно взятом уровне реализуется за $O(b)$
сравнений, и существование искомой константы следует из определения
<<$O$~большого>>.
\end{proof}

\begin{lem} \label{th:one-balancing}
На каждом уровне одновременно не может идти более чем одна балансировка.
\end{lem}
\begin{proof}
Во время каждой операции \textbf{insert} на каждом уровне проделывается
$C$ шагов балансировки, где $C$~--- константа из леммы \ref{th:bal-constant}.
Но эта константа определена так, чтобы балансировка успела завершиться
за $b$ шагов, где $b$~--- минимально возможное количество вставок
до начала следующей балансировки.
\end{proof}

\begin{lem} \label{th:log*-levels}
Количество уровней в \CH[*] (т.~е. \textsf{MaximumLevel}) не превосходит
$\log^* n + 1$.
\end{lem}
\begin{proof}
Из условий на переполнение следует, что если $\mathsf{MaximumLevel} = t$,
то $n \geq {}^{t-1}2$. Значит, $\log^* n \geq t-1$, то есть
$t \leq \log^* n + 1$.
\end{proof}


\begin{lem} \label{th:small-mh-level}
Для любого валидного $t > 0$ верно
$\lev(\MH[t]) \leq t + 1$.
\end{lem}
\begin{proof}
Докажем индукцией по $t$.

Если $t=1$, то все элементы \MH[t]~--- кучи (уровня 1), построенные на элементах буфера
(в случае \CH[r]) или единичные элементы (в случае \CH[*]). В обоих случаях $\lev \MH[1] \leq 2$.

Если $t > 1$, то все элементы \MH[t] имеют уровень, не превосходящий максимальный уровень
\MH[t-1]. Тогда из предположения индукции получаем, что $\lev(\MH[t]) \leq \lev(\MH[t-1]) + 1 \leq t+1$.
\end{proof}


\begin{lem} \label{th:small-hh-level}

\end{lem}
\begin{proof}
\end{proof}


\begin{theorem}[о сохранении инвариантов] \label{th:invar}
В любой момент сохраняются следующие инварианты:
\begin{enumerate}
\item \MH[t] и все её элементы~--- корректные бинарные кучи для любого валидного $t$;
\item \HH и все её элементы~--- корректные бинарные кучи;
\item Если балансировка на $t$-м уровне находится в стадии II, то множество \T[t], которое
вставляется в \MH[t+1]~--- корректная бинарная куча;
\item[4r.] (версия {\CH[r]})\quad $|\HH| \leq 6rk$;
\item[4*.] (версия {\CH[*]})\quad $|\HH| \leq 6k\cdot \log^* n$.
\addtocounter{enumi}{-1}
\end{enumerate}
\end{theorem}
\begin{proof}
Доказательство этой теоремы техническое и построено так же, как и
доказательство теоремы~\ref{theo-invariant}.

При инициализации, когда структура пуста, все инварианты выполнены. Докажем,
что они выполняются после всех операций.

При выполнении операции \textbf{insert} происходит две вещи: непосредственно добавление
элемента в буфер или \MH[1] и, возможно, несколько операций по балансировке. Добавление
в буфер не затрагивает ни одно из интересующих нас множеств. Добавление в \MH[1]
происходит только в \CH[*]. Поскольку в ней нет нулевого уровня балансировки,
на инвариант (3) вставка не влияет. Инвариант (1) сохраняется по свойству вставки в кучу.

Посмотрим на балансировку.

При выполнении первой стадии балансировки, опять же, ни одно из интересующих
нас множеств не изменяется. К моменту завершения первой стадии множетство
\T[0] представляет собой бинарную кучу согласно алгоритму \ref{alg:insert-r}
и в дальнейнем не изменяется до окончания балансировки. Значит, инвариант
(3) выполнен.

При выполнении второй стадии балансировки изменяется только <<будущая>>
версия \MH. К моменту завершения второй стадии <<будущая>> версия является
корректной кучей согласно алгоритмам \ref{alg:insert-r} и \ref{alg:insert-*},
кроме того, вставляемый элемент является корректной кучей по инварианту (3). Значит,
инвариант (1) сохранится во время второй стадии балансировки и её завершения.

Операцию \textbf{extractMin} можно разбить на две части: завершение балансировки
и непосредственно извлечение минимального элемента. Провeдение первой стадии
балансировки не нарушает инварианты, как мы видели ранее. Для завершения
второй стадии необходимо добавить все множества \T[t] и \MH[t] в \HH; все они
являются корректными кучами по инвариантам (1) и (3). Таким образом, мы не нарушим
инварант (2).

Посчитаем, сколько элементов было добавлено в \HH

\end{proof}

\todo{доказать нижнюю оценку при O(1) на добавление}
