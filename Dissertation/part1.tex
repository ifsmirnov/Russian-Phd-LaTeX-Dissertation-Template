\SetKwIF{If}{ElseIf}{Else}{если}{то}{иначе если}{иначе}{}


\chapter{Основная схема} \label{chapt1}

В этой главе будет построена структура данных, реализующая операции \textbf{insert}
за $O(1)$ и \textbf{extractMin} за $O(\log k + \log n)$ сравнений, где
за $n$ обозначено количество вставок, за $k$~--- извлечений к моменту выполнения
очередной операции.

\section{Обзор}
Описываемая структура построена на базе двоичной кучи. Для улучшения
асимптотики используется буферизированная вставка и дополнительный буфер
ограниченного размера для извлечения элементов. Структура состоит из трёх
частей: буфер вставки размера $\log n$, в который добавляются элементы; промежуточной
<<кучи куч>> (двоичной кучи, элементами которой являются другие двоичные кучи);
и конечной кучи (\emph{Head Heap}), буфера для извлечения. Отношение порядка
на множестве непустых двоичных куч порождается отношением порядка на элементах,
лежащих в корне.

При добавлении элемента он попадает в буфер вставки. Затем, если буфер переполняется,
на его элементах строится двоичная куча и добавляется в промежуточную кучу.
Для нахождения и удаления минимального элемента необходимо пробежаться по всем
элементам буфера, а также посмотреть в вершину промежуточной кучи и Head Heap.
После этого элемент нужно удалить из всех куч, в которых он лежит. При этом
удаление минимального элемента из всех куч, кроме Head Heap, происходит следующим образом:
корень удаляется, а оба его поддерева добавляются в Head Heap, если они непусты.

На добавление одного элемента требуется $O(1)$ времени амортизированно: накопив
буфер размера $\log n$, нужно потратить $O(\log n)$ действий на то, чтобы добавить
элемент в промежуточную кучу, что даёт требуемую оценку в среднем.

Можно видеть, что размер Head Heap в любой момент времени не превосходит $O(k)$, где
$k$~--- количество удалений, поскольку глубина любой <<кучи куч>> константна.
Для удаления элемента необходимо: a) просмотреть буфер, b) посмотреть
на корень промежуточной кучи и Head Heap, c) выполнить $O(1)$ вставок в Head Heap.
Части (b) и (c) занимают $O(\log k)$ времени, часть (a)~--- $O(\log n)$.
Узким местом является добавление в буфер. Оказывается, что на буфере можно
рекурсивно построить аналогичную структуру, существенно уменьшив слагаемое
$O(\log n)$ в асимптотике удаления и не ухудшив при этом операцию вставки.

В части (х) будет построена описанная структура данных.
В части (х) будет проведена деамортизация и получены оценки в худшем
случае.
В части (х) оценка на добавление будет улучшена до $O(\log k \cdot \log^*n)$,
а также будут описаны несколько возможных трейд-оффов между временем
добавления и извлечения минимума.

\section{Описание}

\begin{definition}
Пусть $\mathcal{X}$~--- некоторое линейно упорядоченное множество.
Назовём $\mathcal{H}(\mathcal{X})$
множество $\{\mathcal{X} \cup \text{все непустые двоичные кучи над элементами }\mathcal{X}\}$.
Введём на $\mathcal{H}(\mathcal{X})$ линейный порядок следующим образом:
$x < y \xLeftrightarrow{def} repr(x) < repr(y)$, где
$$
repr(x) = \left\lbrace
    \begin{array}{ll}
    x,& x \in \mathcal{X} \\
    x.top(),& x\text{~--- двоичная куча над элементами }\mathcal{X} \\
    \end{array}
\right.
$$
\end{definition}
\begin{designation}
Назовём $\myH_k(\myX)$ множество $\underbrace{\myH(\myH(\dots(}_k\myX)\dots))$.
\end{designation}

Обозначим за $\myX$ множество элементов (то есть пар $(key, item)$),
над которыми оперирует структура данных. На нём определён линейный порядок.

\begin{definition}
$\lev x $--- \emph{уровень} элемента $x$, т.е. минимальное $k: x \in \myH_k(\myX),
x \notin \myH_{k-1}(\myX)$. Иными словами, это максимальная глубина вложенности
двоичных куч внутри элемента.
\end{definition}

Структура данных состоит из трёх частей:
\begin{enumerate}
\item \emph{буфер B}~--- массив элементов $\myX$ размера $b$. $b$ будет
изменяться в процессе работы алгоритма и поддерживаться примерно равным $\log n$.
В начале работы $b=1$.
Элементы изначально попадают в буфер.
\item \emph{промежуточная куча MH (middle heap)}~--- двоичная куча над $\myH(\myX)\setminus\myX$.
При заполнении буфера на нём строится двоичная куча и добавляется в $MH$.
\item \emph{конечная куча HH  (Head Heap)}~--- двоичная куча над $\myH_2(\myX)$.
Её размер всегда равен $O(k)$.
\end{enumerate}

\subsection{Операция вставки} \label{insert}
\begin{algorithm}[h]
 \KwData{$x \in \myX$}
 \If{размер буфера $>b$}{
     создать двоичную кучу $T$ из элементов буфера\;
     очистить буфер\;
     добавить кучу $T$ в $MH$\;
     \If{$n > 2^{b+1}$} {
         $b = b+1$\;
     }
 }
 добавить $x$ в конец буфера\;
 \caption{Операция \textbf{insert}}
 \label{algo-findmin}
\end{algorithm}
\todo{Расписать подробнее, как изменяется размер буфера; как зависит от удалённых элементов?}

\subsection{Операция нахождения минимума}
Максимальный элемент может находиться в любой из трёх частей.
Для его нахождения необходимо просмотреть все элементы $B$, а также
MH.top() и HH.top(), если соответствующая куча
непуста.

\subsection{Операция извлечения минимума} \label{findmin}

Опишем вспомогательную функцию \texttt{Yield}. На вход она принимает
произвольный аргумент из $\myH_2(\myX)$ и возвращает минимальный
элемент из $\myX$, содержащийся в множестве (по сути, корень корня корня...).
Каждая просмотренная вершина удаляется из своей кучи, её оба ребёнка
добавляются в HH.

\todo{алгоритмы надо бы взять в рамочку}

\begin{function}[h]
 \caption{Yield(x)}
 \eIf{$\text{x }\in \myX$}{
     \Return x;
 }{
     \lIf{x.hasLeftChild} {HH.insert(x.leftChild)}
     \lIf{x.hasRightChild} {HH.insert(x.rightChild)}
     \Return \Yield(x.top())\;
 }
\end{function}

\begin{algorithm}[h]
 \KwData{x~--- минимальный элемент или куча, содержащая его}
 \Switch{положение x}{
  \uCase{буфер}{
      удалить x из буфера и вернуть его\;
  }
  \uCase{MH}{
      \Return \Yield(MH)\;
  }
  \Case{HH}{
      T = HH.top()\;
      HH.extractMin()\;
      \Return \Yield(T)\;
  }
 }
 \caption{Операция \textbf{extractMin}}
\end{algorithm}

Для удаления минимального элемента его нужно найти, как описано в пункте \ref{findmin}.
После этого нужно выполнить операцию \textbf{extractMin} из всех куч, содержащих элемент.
Причём <<честно>> эта операция выполняется только для верхнего уровня Head Heap; для
того, чтобы обработать остальные, вызывается процедура \Yield, добавляющая левое
и правое поддерево элемента в HH вместо непосредственно его удаления. Это сделано
для того, чтобы асимптотика операции не зависела от высоты никакой кучи, кроме HH.


\section{Деамортизация}
В данной части будет проведена деамортизация операции добавления, т.е. получена
оценка в $O(1)$ сравнений на добавление в худшем случае, и проведён анализ всех
операций.

\subsection{Куча с версиями}
Для деамортизации нам понадобится частично персистентная куча с поддержкой
отложенных операцией, которую мы назовём \emph{кучей с версиями}.
Неформально говоря, требуется делать следующее: добавлять элемент <<по чуть-чуть>>
так, чтобы он не был виден раньше времени, а потом атомарно <<переключиться>>,
чтобы добавленный элемент появился в куче. Кроме того, необходима возможность
прервать добавление в любой момент.

\begin{definition}
\emph{Куча с версиями}~--- двоичная куча, поддерживающая следующие операции:
\begin{enumerate}
\item Извлечь корень и вернуть два его поддерева. Если в данный момент происходит
    вставка, отменить её и также вернуть вставляемый элемент. После этой операции
    добавлений больше не будет.
\item Если в данный момент не происходит вставка, сделать элемент $x$
    текущим вставляемым элементом.
\item Если в данный момент происходит вставка, проделать $t$ операций по вставке.
\item Если вставка происходила и уже закончена, атомарно добавить вставленный элемент.
\end{enumerate}
\end{definition}

В каждой вершине двоичной кучи хранится два указателя на потомков~--- правого
и левого (возможно, пустые). Будем вместо каждого указателя хранить кортеж
пар (указатель, номер версии). Кроме того, в куче будет отдельно храниться
актуальный номер версии $V$. Таким образом, для того, чтобы получить явное дерево,
нужно для каждой вершины взять указатель с максимальной версией, не превосходящей
$V$.

Для выполнения отложенной вставки нужно вставлять элемент как обычно, но вместо
изменения указателей создавать новые, версии $V+1$. После завершения вставки
можно атомарно перейти на новую версию, увеличив $V$. Если необходимо отменить
вставку и удалить корень, нужно просто вернуть оба поддерева корня (согласно версии
$V$) и удалённый элемент и в дальнейшем пользоваться только ссылками версии $V$.

\todo{Насколько формальноо нужно?}

\todo{Расписать, почему версий в каждой вершине будет немного, и как их удалять.
Сказать, как проталкивать версию вглубь при расклеивании дерева.}

\subsection{Деамортизация операции вставки}

Напомним, как проводится операция вставки: элемент добавляется в буфер,
а при заполнении буфера на нём строится двоичная куча и добавляется в
MH. Теперь MH будет кучей с версиями, и работу после переполнения буфера
можно разделить на три итерации:
\begin{enumerate}[label=\Roman*.]
\item Очистить буфер и построить двоичную кучу $T$ на элементах, которые в нём были
\item Отложенно добавить $T$ в MH
\item Переключить версию в MH, чтобы применить добавление
\end{enumerate}
Назовём эту процедуру \emph{балансировкой}.

Все эти операции будут равномерно выполнены, пока буфер заполняется в следующий
раз, требуя $O(1)$ дополнительной работы на каждое добавление элемента.

Сначала мы докажем, что достигается асимптотика в $O(1)$ на добавление в худшем
случае. После будет показано, как поступать с запросами на удаление, пришедшими
в середине балансировки, и что они не ухудшают асипмтотику.

\begin{theorem}\label{theo-mh-size}
Пусть размер буфера равен $b$. Тогда в любой момент времени $|MH| < 2^{b+1}$.
\end{theorem}
\begin{proof}
Пусть $n$~--- количество вызовов операции \textbf{insert}. Тогда
согласно алгоритму \ref{insert} верно $n < 2^{b+1}$. Но $|MH| \leq n$, откуда
следует требуемое неравенство.
\end{proof}

\begin{theorem}\label{theo-balancing-constant}
Пусть размер буфера равен $b$. Тогда существует некоторая константа $C$ такая,
что балансировку можно выполнить за не более чем $b\cdot C$ сравнений в худшем случае.
\end{theorem}
\begin{proof}
Покажем, что каждая часть требует $O(b)$ сравнений.
\begin{enumerate}[label=\Roman*.]
\item Построить двоичную кучу можно за $O(b)$ сравнений, согласно \todo{something by somewhere}
\item Из теоремы \ref{theo-mh-size} получаем, что высота $MH$ не превосходит $b$. Значит,
добавление возможно за $O(b)$, согласно \todo{something by somewhere}.
\item Переключение версии требует 0 сравнений.
\end{enumerate}
Каждый шаг выполняется за $O(b)$, значит, балансировка в целом выполняется за $O(b)$.
\end{proof}

Для ребалансировки буфера размера $b$ нужно после каждого из последующих $b$
добавлений проделывать $C$ операций процедур I, II, III после добавления.
Таким образом, к моменту следующего переполнения буфера балансировка будет закончена.

\subsection{Удаления в процессе балансировки}

Во время балансировки структура находится в нестабильном состоянии. Если
в это время поступает запрос \textbf{extractMin}, необходимо отменить балансировку,
при этом не потеряв никакой информации. В этой главе будет описано, как это делать
в зависимости от того, во время какой стадии балансировки пришёл запрос.

Кроме этого, хотелось бы не добавлять слагаемых $O(\log n)$ в асимптотику удаления,
оставив из обязательных операций с такой сложностью только просмотр буфера,
поскольку это будет играть роль в дальнейших оптимизациях.

Между очисткой буфера и переключением версии MH старые элементы буфера находятся
<<в подвешенном состоянии>>. Назовём их множество $T$. В течение операции I $T$~---
строящаяся двоичная куча, в течение операции II~--- двоичная куча, после операции III
$T$ перестаёт существовать. Таким образом, во случае поступления запроса на удаление
во время операций I и II необходимо также просмотреть множество $T$ на предмет
наличия в нём максимального элемента.

Рассмотрим, как производить удаление минимума в зависимости от стадии балансировки
и от того, где находится минимальный элемент.

\paragraph{I. Построение кучи}
\begin{itemize}
\item Если минимальный элемент найден в буфере, удалить его и ничего больше не делать.
\item Если минимальный элемент найден в множестве $T$, достроить бинарную кучу на $T$,
извлечь минимум из $T$, добавить $T$ в HH, отменить балансировку
и вернуть извлечённый минимум.
\item Если минимальный элемент найден в MH или в HH, удалить его согласно алгоритму \ref{algo-findmin}.
\end{itemize}

\paragraph{II. Добавление $T$ в MH}
В этом случае необходимо добавить $T$ в $MH$, отменить балансировку и найти и удалить
минимальный элемент согласно алгоритму \ref{algo-findmin}.

\paragraph{III. Переключение версии / После балансировки}
Операция III атомарна, поэтому в процессе её выполнения запрос на удаление прийти не может.
Если запрос пришёл после выполнения балансировки, нужно найти и удалить минимальный
элемент согласно алгоритму \ref{algo-findmin}.

Таким образом, мы готовы сформулировать итоговый алгоритм добавления в кучу
и удаления из неё минимального элемента.

\newcommand{\BalState}{\texttt{BalancingState} }
\newcommand{\BufCap}{\texttt{BufferCapacity} }
\newcommand{\BufSize}{\texttt{BufferSize} }
\newcommand{\ElemCount}{\texttt{InsertionsCount} }
\newcommand{\myC}{\texttt{C} }
\newcommand{\NoAction}{\texttt{NoAction} }
\newcommand{\StateI}{\texttt{StateI} }
\newcommand{\StateII}{\texttt{StateII} }
\newcommand{\Gets}{\ $\gets$\ }
\newcommand{\Loc}{\texttt{Location} }
 
\section{Алгоритм}
Алгоритмы \ref{algo-init-deamort}, \ref{algo-insert-deamort}, \ref{algo-extractmin-deamort}
описывают соответственно инициализацию структуры данных, добавление элемента и извлечение
минимального элемента.

\begin{algorithm}[h]
 \Begin{
     \BalState \Gets \NoAction \;
     \BufCap \Gets 1\;
     \BufSize \Gets \BufCap \;
     \ElemCount \Gets 1\;
     \myC \Gets константа из теор. \ref{theo-balancing-constant} \;
 }
 \caption{Инициализация деамортизированной кучи}
 \label{algo-init-deamort}
\end{algorithm}

\begin{algorithm}[h]
 \KwData{$x \in \myX$}
 \Begin{
%      \If{\BalState\ $\in$ \{\StateI, \StateII\}}{
     \If{\BalState\ $\in$ \texttt{\{}\StateI, \StateII\texttt{\}}}{
        выполнить \myC операций по балансировке\;
        \If{закончилась стадия I}{
            \BalState \Gets \StateII\;
        }
        \If{закончилась стадия II}{
            выполнить переключение версии MH\;
            \BalState \Gets \NoAction\;
        }
     }
     добавить $x$ в конец буфера\;
     \BufSize \Gets \BufSize + 1\;
     \ElemCount \Gets \ElemCount + 1\;
     \If{\BufSize =\ \BufCap}{
        \BufSize \Gets 0\;
        \BalState \Gets \StateI\;
        начать балансировку на элементах буфера и очистить буфер\;
        \While{$\ElemCount > 2^{\BufCap}$}{
            \BufCap \Gets \BufCap + 1\;
        }
     }
 }
 \caption{Операция \textbf{insert} в деамортизированной куче}
 \label{algo-insert-deamort}
\end{algorithm}

\begin{algorithm}[h]
 \Begin{
     \If{\BalState =\ \StateI}{
         закончить построение кучи на T\;
         добавить T в HH\;
     }
     \If{\BalState =\ \StateII}{
         \tcp{экстренно завершаем балансировку}
         \BalState \Gets \NoAction\;
         отменить отложенное добавление в MH\;
         добавить T в HH\;
     }
     \BalState \Gets 0\;
     просмотреть буфер B\;
     просмотреть вершины MH и HH, если соответствующие кучи непусты\;
     среди просмотренных элементов определить положение
     минимального элемента \Loc: B, MH, HH\;
     \Switch{\Loc}{
         \uCase{B}{
             удалить минимум из буфера\;
         }
         \uCase{MH}{
             \Return \Yield(MH)\;
         }
         \uCase{HH}{
             T = HH.top()\;
             HH.extractMin()\;
             \Return \Yield(T)\;
         }
     }
 }
 \caption{Операция \textbf{extractMin} в деамортизированной куче}
 \label{algo-extractmin-deamort}
\end{algorithm}

\subsection{Доказательство корректности}
Тут ещё ничего нет (\todo{А что вообще должно быть?})
\subsection{Доказательство времени работы}
Тут ещё ничего нет (\todo{А будет ссылка на две теоремы
и доказательство маленькой высоты HH})
