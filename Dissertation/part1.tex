\SetKwIF{If}{ElseIf}{Else}{если}{то}{иначе если}{иначе}{}


\chapter{Основная схема} \label{chapt-sch}

В этой главе будет построена структура данных \SCH, реализующая операции \textbf{insert}
% В этой главе будет построена структура данных \texttt{SimpleCascadeHeap},
% реализующая операции \textbf{insert}
за $O(1)$ и \textbf{extractMin} за $O(\log k + \log n)$ сравнений, где
за $n$ обозначено количество вставок, за $k$~--- извлечений к моменту выполнения
очередной операции.

\section{Обзор}
\SCH построена на базе двоичной кучи. Для улучшения
% \texttt{SimpleCascadeHeap} построена на базе двоичной кучи. Для улучшения
асимптотики используется буферизированная вставка и дополнительный буфер
ограниченного размера для извлечения элементов. Структура состоит из трёх
частей: буфер вставки размера $\log n$, в который добавляются элементы; промежуточной
<<кучи куч>> (двоичной кучи, элементами которой являются другие двоичные кучи);
и конечной кучи (\emph{Head Heap}), буфера для извлечения. Отношение порядка
на множестве непустых двоичных куч порождается отношением порядка на элементах,
лежащих в корне.

При добавлении элемента он попадает в буфер вставки. Затем, если буфер переполняется,
на его элементах строится двоичная куча и добавляется в промежуточную кучу.
Для нахождения и удаления минимального элемента необходимо пробежаться по всем
элементам буфера, а также посмотреть в вершину промежуточной кучи и Head Heap.
После этого элемент нужно удалить из всех куч, в которых он лежит. При этом
удаление минимального элемента из всех куч, кроме Head Heap, происходит следующим образом:
корень удаляется, а оба его поддерева добавляются в Head Heap, если они непусты.

На добавление одного элемента требуется $O(1)$ времени амортизированно: накопив
буфер размера $\log n$, нужно потратить $O(\log n)$ действий на то, чтобы добавить
элемент в промежуточную кучу, что даёт требуемую оценку в среднем.

Можно видеть, что размер Head Heap в любой момент времени не превосходит $O(k)$, где
$k$~--- количество удалений, поскольку глубина любой <<кучи куч>> константна.
Для удаления элемента необходимо: a) просмотреть буфер, b) посмотреть
на корень промежуточной кучи и Head Heap, c) выполнить $O(1)$ вставок в Head Heap.
Части (b) и (c) занимают $O(\log k)$ времени, часть (a)~--- $O(\log n)$.
Узким местом является добавление в буфер. Оказывается, что на буфере можно
рекурсивно построить аналогичную структуру, существенно уменьшив слагаемое
$O(\log n)$ в асимптотике удаления и не ухудшив при этом операцию вставки.

В главе \ref{chapt-sch} будет построена описанная структура данных,
проведена деамортизация и получены оценки в худшем случае.
В части \ref{chapt-ch} будет построена улучшенная версия
структуры под названием \CH,
оценка на добавление будет улучшена до $O(\log k \cdot \log^*n)$,
а также будут описаны несколько возможных трейд-оффов между временем
добавления и извлечения минимума.

\section{Описание}

\begin{definition}
Пусть $\mathcal{X}$~--- некоторое линейно упорядоченное множество.
Назовём $\mathcal{H}(\mathcal{X})$
множество $\{\mathcal{X} \cup \text{все непустые двоичные кучи над элементами }\mathcal{X}\}$.
Введём на $\mathcal{H}(\mathcal{X})$ линейный порядок следующим образом:
$x < y \xLeftrightarrow{def} repr(x) < repr(y)$, где
$$
repr(x) = \left\lbrace
    \begin{array}{ll}
    x,& x \in \mathcal{X} \\
    x.top(),& x\text{~--- двоичная куча над элементами }\mathcal{X} \\
    \end{array}
\right.
$$
\end{definition}
\begin{designation}
Назовём $\myH_k(\myX)$ множество $\underbrace{\myH(\myH(\dots(}_k\myX)\dots))$.
\end{designation}

Обозначим за $\myX$ множество элементов (то есть пар $(key, item)$),
над которыми оперирует структура данных. На нём определён линейный порядок.

\begin{definition}
$\lev x $--- \emph{уровень} элемента $x$, т.е. минимальное $k: x \in \myH_k(\myX),
x \notin \myH_{k-1}(\myX)$. Иными словами, это максимальная глубина вложенности
двоичных куч внутри элемента.
\end{definition}

Структура данных состоит из трёх частей:
\begin{enumerate}
\item \emph{буфер B}~--- массив элементов $\myX$ размера $b$. $b$ будет
изменяться в процессе работы алгоритма и поддерживаться примерно равным $\log n$.
В начале работы $b=1$.
Элементы изначально попадают в буфер.
\item \emph{промежуточная куча \MH (middle heap)}~--- двоичная куча над $\myH(\myX)\setminus\myX$.
При заполнении буфера на нём строится двоичная куча и добавляется в \MH.
\item \emph{конечная куча \HH  (Head Heap)}~--- двоичная куча над $\myH_2(\myX)$.
Её размер всегда равен $O(k)$.
\end{enumerate}

\subsection{Операция вставки} \label{insert}
\begin{algorithm}[h]
 \KwData{$x \in \myX$}
 добавить $x$ в конец буфера\;
 \If{размер буфера $> log_2 n$}{
     создать двоичную кучу $T$ из элементов буфера\;
     очистить буфер\;
     добавить кучу $T$ в \MH\;
 }
 \caption{Операция \textbf{insert}}
 \label{algo-findmin}
\end{algorithm}

\subsection{Операция извлечения минимума} \label{findmin}
Добавим \MH в \HH. После этого максимальный элемент может находиться
либо в буфере, либо в вершине \HH. Просмотрим все элементы буфера
за $O(|B|)$ и вершину \HH. Если минимум найден в буфере, удалим его
и вернём. Иначе нужно удалить корень из \HH. 

Сложность в том, что вершины \HH~--- не элементы, а кучи. Опишем,
как корректно производить удаление в таком случае. Для этого введём
вспомогательную функцию \texttt{Yield}. На вход она принимает
произвольный аргумент из $\myH_2(\myX)$ и возвращает минимальный
элемент из $\myX$, содержащийся в множестве (по сути, корень корня корня...).
Каждая просмотренная вершина удаляется из своей кучи, её оба ребёнка
добавляются в \HH.

\begin{function}[h]
 \caption{Yield(x)}
 \eIf{$\text{x }\in \myX$}{
     \Return x;
 }{
     \lIf{x.hasLeftChild} {\HH.insert(x.leftChild)}
     \lIf{x.hasRightChild} {\HH.insert(x.rightChild)}
     \Return \Yield(x.top())\;
 }
\end{function}

\begin{algorithm}[h]
 \KwData{x~--- минимальный элемент или куча, содержащая его}
 \Switch{положение x}{
  \uCase{буфер}{
      удалить x из буфера и вернуть его\;
  }
  \Case{\HH}{
      T = \HH.top()\;
      \HH.extractMin()\;
      \Return \Yield(T)\;
  }
 }
 \caption{Операция \textbf{extractMin}}
 \label{algo-extractmin-simple}
\end{algorithm}

Теперь мы готовы описать алгоритм извлечения минимума (алгоритм \ref{algo-extractmin-simple}).
Для удаления минимального элемента его нужно найти, просмотрев буфер и корень \HH.
После этого нужно выполнить операцию \textbf{extractMin} из всех куч, содержащих элемент.
Причём <<честно>> эта операция выполняется только для верхнего уровня Head Heap; для
того, чтобы обработать остальные, вызывается процедура \Yield, добавляющая левое
и правое поддерево элемента в \HH вместо непосредственно его удаления. Это сделано
для того, чтобы асимптотика операции не зависела от высоты никакой кучи, кроме \HH.

\section{Деамортизация}
В данной части будет проведена деамортизация операции добавления, т.е. получена
оценка в $O(1)$ сравнений на добавление в худшем случае, и проведён анализ всех
операций.

\input{Dissertation/heap_with_versions}

\subsection{Деамортизация операции вставки}

Напомним, как проводится операция вставки: элемент добавляется в буфер,
а при заполнении буфера на нём строится двоичная куча и добавляется в
\MH. Теперь \MH будет кучей с версиями, и работу после переполнения буфера
можно разделить на три итерации:
\begin{enumerate}[label=\Roman*.]
\item Очистить буфер и построить двоичную кучу $T$ на элементах, которые в нём были
\item Отложенно добавить $T$ в \MH
\item Переключить версию в \MH, чтобы применить добавление
\end{enumerate}
Назовём эту процедуру \emph{балансировкой}.

Все эти операции будут равномерно выполнены, пока буфер заполняется в следующий
раз, требуя $O(1)$ дополнительной работы на каждое добавление элемента.
Это будет доказано в разделе \ref{proof-simple}.

Для балансировки буфера размера $b$ нужно после каждого из последующих $b$
добавлений проделывать $C$ операций процедур I, II, III после добавления.
Таким образом, к моменту следующего переполнения буфера балансировка будет закончена.

\subsection{Удаления в процессе балансировки}

Во время балансировки структура находится в нестабильном состоянии. Если
в это время поступает запрос \textbf{extractMin}, необходимо отменить балансировку,
при этом не потеряв никакой информации. В этой главе будет описано, как это делать
в зависимости от того, во время какой стадии балансировки пришёл запрос.

Кроме этого, хотелось бы не добавлять слагаемых $O(\log n)$ в асимптотику удаления,
оставив из обязательных операций с такой сложностью только просмотр буфера,
поскольку это будет играть роль в дальнейших оптимизациях.

Между очисткой буфера и переключением версии \MH старые элементы буфера находятся
<<в подвешенном состоянии>>. Назовём их множество $T$. В течение операции I $T$~---
строящаяся двоичная куча, в течение операции II~--- двоичная куча, после операции III
$T$ перестаёт существовать. Таким образом, во случае поступления запроса на удаление
во время операций I и II необходимо также просмотреть множество $T$ на предмет
наличия в нём максимального элемента.

Рассмотрим, как производить удаление минимума в зависимости от стадии балансировки
и от того, где находится минимальный элемент.

\paragraph{I. Построение кучи}
\begin{itemize}
\item Если минимальный элемент найден в буфере, удалить его и ничего больше не делать.
\item Если минимальный элемент найден в множестве $T$, достроить бинарную кучу на $T$,
извлечь минимум из $T$, добавить $T$ в \HH, отменить балансировку
и вернуть извлечённый минимум.
\item Если минимальный элемент найден в \MH или в \HH, удалить его согласно алгоритму \ref{algo-findmin}.
\end{itemize}

\paragraph{II. Добавление $T$ в \MH}
В этом случае необходимо добавить $T$ в \MH, отменить балансировку и найти и удалить
минимальный элемент согласно алгоритму \ref{algo-findmin}.

\paragraph{III. Переключение версии / После балансировки}
Операция III атомарна, поэтому в процессе её выполнения запрос на удаление прийти не может.
Если запрос пришёл после выполнения балансировки, нужно найти и удалить минимальный
элемент согласно алгоритму \ref{algo-findmin}.

Таким образом, мы готовы сформулировать итоговый алгоритм добавления в кучу
и удаления из неё минимального элемента.

\newcommand{\BalState}{\texttt{BalancingState}\xspace}
\newcommand{\BufSize}{\texttt{BufferSize}\xspace}
\newcommand{\ElemCount}{\texttt{InsertionsCount}\xspace}
\newcommand{\myC}{\texttt{C}\xspace}
\newcommand{\NoAction}{\texttt{NoAction}\xspace}
\newcommand{\StateI}{\texttt{StateI}\xspace}
\newcommand{\StateII}{\texttt{StateII}\xspace}
\newcommand{\Gets}{\ $\gets$\ }
\newcommand{\Loc}{\texttt{Location}\xspace}
 
\section{Алгоритм}
Алгоритмы \ref{algo-init-deamort}, \ref{algo-insert-deamort}, \ref{algo-extractmin-deamort}
описывают соответственно инициализацию структуры данных, добавление элемента и извлечение
минимального элемента.

\begin{algorithm}[h]
 \Begin{
     \BalState \Gets \NoAction \;
     \BufSize \Gets 0\;
     \ElemCount \Gets 1\;
     \myC \Gets константа из леммы \ref{theo-balancing-constant} \;
 }
 \caption{Инициализация деамортизированной кучи}
 \label{algo-init-deamort}
\end{algorithm}

\begin{algorithm}[h]
 \KwData{$x \in \myX$}
 \Begin{
     \If{$\BalState\ \in \{\StateI, \StateII\}$}{
        выполнить \myC операций по балансировке\;
        \If{закончилась стадия I}{
            \BalState \Gets \StateII\;
        }
        \If{закончилась стадия II}{
            выполнить переключение версии \MH\;
            \BalState \Gets \NoAction\;
        }
     }
     добавить $x$ в конец буфера\;
     \BufSize \Gets \BufSize + 1\;
     \ElemCount \Gets \ElemCount + 1\;
     \If{$\BufSize > \log_2 \ElemCount$}{
        \BufSize \Gets 0\;
        \BalState \Gets \StateI\;
        начать балансировку на элементах буфера и очистить буфер\;
     }
 }
 \caption{Операция \textbf{insert} в деамортизированной куче}
 \label{algo-insert-deamort}
\end{algorithm}

\begin{algorithm}[h]
 \Begin{
     \If{\BalState =\ \StateI}{
         закончить построение кучи на T\;
         добавить T в \HH\;
     }
     \If{\BalState =\ \StateII}{
         \tcp{экстренно завершаем балансировку}
         \BalState \Gets \NoAction\;
         отменить отложенное добавление в \MH\;
         добавить T в \HH\;
     }
     \BalState \Gets 0\;
     просмотреть буфер B\;
     просмотреть вершины \MH и \HH, если соответствующие кучи непусты\;
     среди просмотренных элементов определить положение
     минимального элемента \Loc: B, \MH, \HH\;
     \Switch{\Loc}{
         \uCase{B}{
             удалить минимум из буфера\;
         }
         \uCase{\MH}{
             \Return \Yield(\MH)\;
         }
         \uCase{\HH}{
             T = \HH.top()\;
             \HH.extractMin()\;
             \Return \Yield(T)\;
         }
     }
 }
 \caption{Операция \textbf{extractMin} в деамортизированной куче}
 \label{algo-extractmin-deamort}
\end{algorithm}

\section{Доказательство корректности и асимптотики} \label{proof-simple}
\input{Dissertation/proof_simple.tex}
