\chapter{Основная схема} \label{chapt-sch}

В этой главе будет построена структура данных \SCH, реализующая операции \textbf{insert}
за $O(1)$ и \textbf{extractMin} за $O(\log k + \log n)$\footnote{
    Вообще говоря, $k\leq n$, поэтому здесь можно написать $O(\log n)$.
Однако для общности с полученными в следующей главе асимптотиками
здесь будет использована именно такая запись.}
сравнений, где
за $n$ обозначено количество вставок, за $k$ "--- извлечений к моменту выполнения
очередной операции.
\section{Обзор}
\SCH будет построена на базе двоичной кучи. Для улучшения
асимптотики будет использоваться  буферизированная вставка и дополнительный буфер
ограниченного размера для извлечения элементов. Структура будет состоять из трёх
частей: буфер вставки размера $\log n$, в который добавляются элементы; промежуточной
<<кучи куч>> (двоичной кучи, элементами которой являются другие двоичные кучи)
\emph{Middle Heap} (\MH);
и конечной кучи (\emph{Head Heap}, \HH), буфера для извлечения.

Отношение порядка
на множестве непустых двоичных куч порождается отношением порядка на элементах,
лежащих в корне. То есть для сравнения двух куч нужно сравнить минимальные элементы
каждой из них.

При добавлении элемента он попадает в буфер вставки. Затем, если буфер переполняется,
на его элементах строится двоичная куча и добавляется в Middle Heap.

Для нахождения и удаления минимального элемента необходимо пробежаться по всем
элементам буфера, а также посмотреть в вершину Middle Heap и Head Heap.
После этого элемент нужно удалить из той кучи, в которой он найден. При этом
удаление минимального элемента из всех куч, кроме Head Heap, происходит следующим образом:
корень удаляется, а оба его поддерева добавляются в Head Heap, если они непусты.  
Таким образом размер Heap Heap поддерживается равным $O(k)$, и все операции, кроме
просмотра буфера, выполняются за $O(\log |\HH|)$ и не зависят от высоты других куч.

На добавление одного элемента требуется $O(1)$ времени амортизированно: накопив
буфер размера $\log n$, нужно потратить $O(\log n)$ действий на то, чтобы добавить
элемент в промежуточную кучу, что даёт требуемую оценку в среднем.

Можно видеть, что размер Head Heap в любой момент времени не превосходит $O(k)$, где
$k$ "--- количество удалений, поскольку глубина любой <<кучи куч>> константна.
Для удаления элемента необходимо: a) просмотреть буфер, b) посмотреть
на корень промежуточной кучи и Head Heap, c) выполнить $O(1)$ вставок в Head Heap.
Части (b) и (c) занимают $O(\log k)$ времени, часть (a) "--- $O(\log n)$.
Узким местом является добавление в буфер. Оказывается, что на буфере можно
рекурсивно построить аналогичную структуру, существенно уменьшив слагаемое
$O(\log n)$ в асимптотике удаления и не ухудшив при этом операцию вставки.

Далее в этой главе будет построена описанная структура данных,
проведена деамортизация и получены оценки в худшем случае.
В главе \ref{chapt-ch} будет построена улучшенная версия
структуры под названием \CH,
оценка на извлечение минимума будет улучшена до $O(\log^* n (\log k + \log \log^* n))$,
а также будут описаны возможные трейд-оффы между временем
добавления и извлечения минимума.

\section{Описание}

\begin{definition}
Пусть $\mathcal{X}$ "--- некоторое линейно упорядоченное множество.
Назовём $\mathcal{H}(\mathcal{X})$
множество $\{\mathcal{X} \cup \text{все непустые двоичные кучи над элементами }\mathcal{X}\}$.
Введём на $\mathcal{H}(\mathcal{X})$ линейный порядок следующим образом:
$x < y \xLeftrightarrow{def} repr(x) < repr(y)$, где
\[
repr(x) = \left\lbrace
    \begin{array}{ll}
    x,& x \in \mathcal{X} \\
    x.top(),& x\text{ "--- двоичная куча над элементами }\mathcal{X} \\
    \end{array}
\right.
\]
Иными словами, $repr(x)$ "--- минимальный представитель объекта $x$.
\end{definition}
\begin{designation}
Назовём $\myH_k(\myX)$ множество $\underbrace{\myH(\myH(\dots(}_k\myX)\dots))$.
\end{designation}

Обозначим за $\myX$ множество элементов (то есть пар $(key, item)$),
над которыми оперирует структура данных. На нём определён линейный порядок.

\begin{definition}
$\lev(x) $--- \emph{уровень} элемента $x$, т.е. минимальное $k: x \in \myH_k(\myX),
x \notin \myH_{k-1}(\myX)$. Иными словами, это максимальная глубина вложенности
двоичных куч внутри элемента.
\end{definition}

Структура данных состоит из трёх частей:
\begin{enumerate}
\item \emph{буфер B} "--- массив элементов $\myX$ размера $b$. $b$ будет
изменяться в процессе работы алгоритма и поддерживаться примерно равным $\log n$
(формально ограничения на размер буфера описаны в алгоритме~\ref{algo-insert}).
В начале работы $b=1$.
Элементы изначально попадают в буфер.
\item \emph{промежуточная куча \MH (middle heap)} "--- двоичная куча над $\myH(\myX)\setminus\myX$.
При заполнении буфера на нём строится двоичная куча и добавляется в \MH.
\item \emph{конечная куча \HH  (Head Heap)} "--- двоичная куча над $\myH_2(\myX)$.
Её размер всегда равен $O(k)$.
\end{enumerate}

\subsection{Операция вставки} \label{insert}
\begin{algorithm}[h]
\DefineAlgoKeywords
 \KwData{$x \in \myX$}
 добавить $x$ в конец буфера\;
 \If{размер буфера $> \log_2 n$}{
     создать двоичную кучу $T$ из элементов буфера\;
     очистить буфер\;
     добавить кучу $T$ в \MH\;
 }
 \caption{Операция \textbf{insert}}
 \label{algo-insert}
\end{algorithm}

\subsection{Операция извлечения минимума} \label{findmin}
Добавим \MH в \HH. После этого максимальный элемент может находиться
либо в буфере, либо в вершине \HH. Просмотрим все элементы буфера
за $O(|B|)$ и вершину \HH. Если минимум найден в буфере, удалим его
и вернём. Иначе нужно удалить корень из \HH. 

Сложность в том, что вершины \HH "--- не элементы, а кучи. Опишем,
как корректно производить удаление в таком случае. Для этого введём
вспомогательную функцию \texttt{Yield}. На вход она принимает
произвольный аргумент из $\myH_2(\myX)$ и возвращает минимальный
элемент из $\myX$, содержащийся в множестве (по сути, корень корня корня...).
Каждая просмотренная вершина удаляется из своей кучи, её оба ребёнка
добавляются в \HH.

\begin{function}[h]
 \caption{Yield(x)}
 \eIf{$\text{x }\in \myX$}{
     \Return x;
 }{
     \lIf{x.hasLeftChild} {\HH.insert(x.leftChild)}
     \lIf{x.hasRightChild} {\HH.insert(x.rightChild)}
     \Return \Yield(x.top())\;
 }
\end{function}

\begin{algorithm}[h]
\DefineAlgoKeywords
 \KwData{\x "--- минимальный элемент или куча, содержащая его}
 \Switch{положение \x}{
  \uCase{буфер}{
      удалить \x из буфера и вернуть его\;
  }
  \Case{\HH}{
      T = \HH.top()\;
      \HH.extractMin()\;
      \Return \Yield(T)\;
  }
 }
 \caption{Операция \textbf{extractMin}}
 \label{algo-extractmin-simple}
\end{algorithm}

Теперь мы готовы описать алгоритм извлечения минимума (алгоритм \ref{algo-extractmin-simple}).
Для удаления минимального элемента его нужно найти, просмотрев буфер и корень \HH.
После этого нужно выполнить операцию \textbf{extractMin} из всех куч, содержащих элемент.
Причём <<честно>> эта операция выполняется только для верхнего уровня Head Heap; для
того, чтобы обработать остальные, вызывается процедура \Yield, добавляющая левое
и правое поддерево элемента в \HH вместо непосредственно его удаления. Это сделано
для того, чтобы асимптотика операции не зависела от высоты никакой кучи, кроме \HH.

\section{Деамортизация} \label{deamort-simple}
В данной части будет проведена деамортизация операции добавления, т.е. получена
оценка в $O(1)$ сравнений на добавление в худшем случае, и проведён анализ всех
операций.

\input{Dissertation/heap_with_versions}

\subsection{Деамортизация операции вставки}

Напомним, как проводится операция вставки: элемент добавляется в буфер,
а при заполнении буфера на нём строится двоичная куча и добавляется в
\MH. Теперь \MH будет кучей с версиями, и работу после переполнения буфера
можно разделить на три итерации:
\begin{enumerate}[label=\Roman*.]
\item Очистить буфер и построить двоичную кучу $T$ на элементах, которые в нём были
\item Отложенно добавить $T$ в \MH
\item Переключить версию в \MH, чтобы применить добавление
\end{enumerate}
Назовём эту процедуру \emph{балансировкой}.

Все эти операции будут равномерно выполнены, пока буфер заполняется в следующий
раз, требуя $O(1)$ дополнительной работы на каждое добавление элемента.
Это будет доказано в разделе \ref{ch:proof-simple}.

Для балансировки буфера размера $b$ нужно после каждого из последующих $b$
добавлений проделывать $C$ операций процедур I, II, III после добавления.
Таким образом, к моменту следующего переполнения буфера балансировка будет закончена.

\subsection{Удаления в процессе балансировки}

Во время балансировки структура находится в нестабильном состоянии. Если
в это время поступает запрос \textbf{extractMin}, необходимо отменить балансировку,
при этом не потеряв никакой информации. В этой главе будет описано, как это делать
в зависимости от того, во время какой стадии балансировки пришёл запрос.

Если балансировка находится в I стадии, необходимо достроить двоичную кучу на множестве
$T$, тем самым переведя балансировку в стадию II.  
Если балансировка находится в II стадии (в том числе после выполнения только что
описанной операции), необходимо вставить $T$ в \HH. После этого нужно в любом
случае вставить \MH в \HH.

После подготовки к удалению \MH оказывается пуста. Таким образом, для удаления
минимума достаточно просмотреть буфер и корень \HH так же,
как было описано в параграфе \ref{findmin}.

Теперь мы готовы целиком описать алгоритмы вставки в \SCH и удаления минимума.

\section{Алгоритм}
Алгоритмы \ref{algo-init-deamort}, \ref{algo-insert-deamort}, \ref{algo-extractmin-deamort}
описывают соответственно инициализацию структуры данных, добавление элемента и извлечение
минимального элемента.

\begin{algorithm}[t]
\DefineAlgoKeywords
\Begin{
    \BalState \Gets \NoAction \;
    \BufSize \Gets 0\;
    \ElemCount \Gets 0\;
    \C \Gets константа из леммы \ref{theo-balancing-constant} \;
}
\caption{Инициализация деамортизированной кучи}
\label{algo-init-deamort}
\end{algorithm}

\begin{algorithm}[p]
\DefineAlgoKeywords
 \KwData{$\x \in \myX$}
 \Begin{
     \If{$\BalState\ \in \{\StateI, \StateII\}$}{
        выполнить \C операций по балансировке\;
        \If{закончилась стадия I}{
            \BalState \Gets \StateII\;
        }
        \If{закончилась стадия II}{
            выполнить переключение версии \MH\;
            \BalState \Gets \NoAction\;
        }
     }
     добавить \x в конец буфера\;
     \BufSize \Gets \BufSize + 1\;
     \ElemCount \Gets \ElemCount + 1\;
     \If{$\BufSize > \log_2 \ElemCount$}{
        \BufSize \Gets 0\;
        \BalState \Gets \StateI\;
        начать балансировку на элементах буфера и очистить буфер\;
     }
 }
 \caption{Операция \textbf{insert} в деамортизированной куче}
 \label{algo-insert-deamort}
\end{algorithm}

\begin{algorithm}[p]
\DefineAlgoKeywords
 \Begin{
     \If{\BalState =\ \StateI}{
         закончить построение кучи на \T\;
         добавить \T в \HH\;
     }
     \If{\BalState =\ \StateII}{
         отменить отложенное добавление в \MH\;
         добавить \T в \HH\;
     }
     \lIf{\MH непуста}{
         вставить \MH в \HH
     }
     \BalState \Gets \NoAction\;
     просмотреть буфер B и вершину \HH, если куча непуста,
     найти среди них минимальный элемент\;
     \eIf{минимум в B}{
         удалить минимум из буфера\;
     }{
         T = \HH.top()\;
         \HH.extractMin()\;
         \Return \Yield(T)\;
     }
 }
 \caption{Операция \textbf{extractMin} в деамортизированной куче}
 \label{algo-extractmin-deamort}
\end{algorithm}

\newpage
\section{Доказательство корректности и асимптотики} \label{ch:proof-simple}
\input{Dissertation/proof_simple.tex}
