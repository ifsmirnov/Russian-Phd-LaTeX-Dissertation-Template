\chapter{Заключение} \label{chapt3}

Нами была построена структура данных \CH, улучшающая известные на данный момент
верхние оценки на реализацию очереди с приоритетом при ограниченном
числе удалений. Построенная нами оценка очень близка к теоретически оптимальной.

Прикладной ценности наша стуктура данных не имеет из-за очень высокой скрытой
в асимптотике константы. Однако полученный результат может использоваться
для улучшения верхних оценок других алгоритмов.

Ниже в этой главе мы рассмотрим возможное применение \CH и опишем
возможные дальнейшие направления работы по теме.

\section{Применение к задачам частичной сортировки}

Задача \PartSort~--- это упрощённая форма задачи сортировки.\cite{partial-sort}
В ней требуется по множеству из $n$ сравнимых элементов выдать $k$ наименьших
в отсортированном порядке. При $k=n$ задача \PartSort эквивалентна сортировке.

\begin{theorem} \label{th:part-sort}
Любое решение задачи \PartSort при $k > 0$ требует $\Omega(n + k \log k)$ сравнений
в худшем случае.
\end{theorem}
\begin{proof}
Задача \PartSort сводится к задачам выбора наименьших $k$ элементов
и их сортировки. Отсортировать $k$ элементов невозможно быстрее,
чем за $\Omega(k \log k)$ из теоретико-информационных соображений\cite[с.~222]{Cormen}.\
Для выбора наименьших
$k$ элементов нужно как минимум выбрать минимальный, что
требует $n-1 = \Omega(n)$ сравнений. Сумма этих нижних оценок даёт требуемую
оценку в $\Omega(n+k\log k)$.
\end{proof}

Объявленная оценка является строгой: существуют алгоритмы, решающие
\PartSort за $O(n + k \log k)$; самый простой из них построен на базе
QuickSort и QuickSelect.

Задача \IncSort~--- усложнённая версия задачи \PartSort. В этой формулировке,
как и прежде, все элементы заданы заранее, однако значение $k$ заранее неизвестно
и требуется уметь быстро переходить от $k$ отсортированных минимальных элементов
к $k+1$ (иначе говоря, каждый раз возвращать минимальный элемент среди
оставшихся). Ясно, что \IncSort не проще \PartSort, поэтому нижняя
граница из теор.~\ref{th:part-sort} верна и здесь.
Алгоритм \emph{IncrementalQuickSort}\cite{opt-inc-sort},
достигающий нижнюю оценку амортизированно в худшем случае,
был построен Paredes и Navarro на базе QuickSelect.
Однако алгоритма, достигающего нижней оценки в худшем случае и не амортизированно
(то есть возвращающего $k$-й минимум за $O(\log k)$ с препроцессингом
за $O(n)$) на момент написания статьи нам не известно.

Задачу \PriQ можно назвать усложнённой версией \PartSort. Фактически,
это описание операций очереди с приоритетом: требуется вставлять
элемент в структуру и извлекать из структуры минимальный к данному
моменту элемент. Нижняя оценка из теор.~\ref{th:part-sort} верна и
для этой задачи. Paredes и Navarro представили структуру данных
\emph{QuickHeap}\cite{quick-heap}, решающую эту задачу
за $O(n + k \log k)$ амортизированно и в среднем (представленный ими
алгоритм является вероятностным). Не вероятностное решение этой
задачи с такой асимптотикой авторам не известно, даже
если разрешить амортизированные оценки сложности.

Все упомянутые здесь задачи используются как подзадачи в более
сложных алгоритмах. Например, в работе~\cite{quick-heap} показано,
как использовать \IncSort и \PriQ для оптимизации алгоритмов
Прима и Краскала построения остовного дерева.

Представленная в статье структура данных \CH позволяет
решать три упомянутые здесь задачи в худшем случае и без амортизаци
за лучшую асимптотику, чем было представлено ранее. Теоретическая
оценка достигается с точностью до множителя $\log^*n \cdot \log \log^*n$.
Это можно использовать для улучшения известных верхних оценок
решений некоторых задач.

Стоит заметить, что \CH достаточно сложна и громоздка для реализации
на практике, поэтому, хоть данная оценка и очень близка к теоретически
оптимальной, практической ценности наша структура данных не имеет.

\section{Дальнейшая работа}
Все асимптотические оценки, приведённые в статье, рассматриваются
в модели сравнений. Однако можно немного модифицировать построенную
структуру данных так, чтобы оценки остались верны и в более сложных моделях,
таких, как Pointer Machine и RAM-модель. Для этого требуется более
аккуратный анализ, особенно в части деамортизации. Например, сейчас
операция копирования буфера размера $O(\log^{(r)})$ считается
выполнимой за $O(1)$, поскольку не требует сравнений. Копирование
активно используется в части деамортизации, однако при желании его можно
избежать.

Стоит обратить внимание, что при операции \textbf{extractMin}
все промежуточные кучи очищаются. За счёт этого операция
вставки в \CH[*] на самом деле занимает не $O(\log^* n)$,
а $O(\log^* q)$, где $q$~--- количество вставок с момента последнего
извлечения. Авторам не удалось получить из этого никаких асимптотических
улучшений, однако можно попробовать вывести из этого \emph{queueish}-свойство\footnote{
    Свойство queueish означает, что время доступа к элементу $x$ лежит в $O(\log q(x))$,
    где $q(x)$~--- количество элементов, просмотренных с момента последего доступа к $x$.}
или аналогичные ему.
