\chapter{Улучшение асимптотики} \label{chapt-ch}

В предыдущей главе была описана структура очереди с приоритетом, позволяющая
добавлять элемент за $O(1)$ сравнений и удалять минимум за $O(\log k + \log n)$
сравнений, где $n$ "--- количество добавлений, $k$ "--- количество удалений
к моменту вызова операции удаления. Обе оценки выполняются в худшем случае.

В этой главе вторая оценка будет улучшена.  Будет описана структура данных \CH,
позволяющая улучшить асимптотику удаления до $(O\log k + \log \log \dots \log n)$
для любого наперёд заданного константного числа итераций логарифма, сохранив при
этом константную сложность добавления. Кроме того, (напрямую из предыдущей)
будут получены очереди с приоритетом со сложностью вставки и удаления,
соответственно, ($O(t)$,~$O(t \cdot \log k + \log ^{(t)} n)$) и
($O(\log^* n)$,~$O(\log^* n \cdot \log k)$).

\section*{Анонс???}

Посмотрим на операцию \textbf{extractMin} в структуре данных, описанной в предыдущей
главе. Видно, что узкое место в асимптотике "--- просмотр буфера и достраивание
кучи $T$, если приходится экстренно завершать балансировку на первой стадии:
эта часть работает за $O(\log n)$, в то время как остальные за $O(\log k)$.
Значит, нужно избавиться от полного просмотра буфера при удалении.

Вообще говоря, просматривать весь буфер не нужно, требуется только уметь быстро
находить минимум. Для этого можно рекурсивно построить такую же структуру данных
размера $\log n$ на элементах буфера и вместо просмотра буфера делать запрос к ней.
Во внутренней структуре, в свою очередь, будет свой буфер (размера $\log \log n$).
Появятся две промежуточных кучи MH: одна во внутренней структуре, <<куча куч>>,
вторая "--- во внешней, <<куча куч куч>>. Head Heap сохранится в единственном
экземпляре и будет использоваться как при внутренней балансировке, так и при внешней.

Основная идея \CH заключается в том, чтобы рекурсивно строить аналогичную
структуру на буфере предыдущего уровня до тех пор, пока буфер не станет достаточно
маленького размера. В зависимости от глубины вложенности может достигаться
разная комбинация асимптотик времени добавления и извлечения, как было сказано
в начале этой главы.

В первой части будет описана \CH глубины вложенности 2 с амортизированными оценками
временной сложности. В следующих частях этой главы будет более детально рассмотрена
произвольная глубина вложенности, произведена деамортизация и доказана асимптотика
и корректность.

\section{\CH вложенности 2}
Описываемая в этом разделе структура "--- надстройка над \SCH, в которой
для уменьшения размера буфера добавляется ещё один уровень буферизации.
Это позволяет уменьшить время добавления до $O(\log k + \log \log n)$.

\CH вложенности 2 (или \CH[2]) состоит из следующих частей:

\begin{enumerate}
\item Буфер, куда изначально попадают элементы. Его размер растёт при добавлении
    элементов и поддерживается примерно равным $\log \log n$.
\item Промежуточная куча \MH[2]. Сюда попадают кучи, построенные на элементах
    буфера. Размер \MH[2] не превосходит $O(\log n)$.
\item Промежуточная куча \MH[1], <<куча куч куч>>. Когда \MH[2] становится
    слишком большого размера, её нужно добавить в \MH[1].
\item Конечная куча \HH, используемая так же, как и в \SCH.
\end{enumerate}

Алгоритм~\ref{algo-insert-2} более подробно иллюстрирует вставку элемента.
В данном случае оценка $O(1)$ на вставку амортизированная, деамортизация будет
проведена позже.

\begin{algorithm}[h]
 \KwData{$x \in \myX$}
 добавить $x$ в конец буфера\;
 \If{размер буфера $> \log_2 \log_2 n$}{
     создать двоичную кучу $T$ из элементов буфера\;
     очистить буфер\;
     добавить кучу $T$ в \MH[2]\;
 }
 \If{размер \MH[2] $> \log_2 \log_2 n$}{
     добавить \MH[2] в \MH[1]\;
     очистить \MH[2]\;
 }
 \caption{Операция \textbf{insert} в \CH[2]}
 \label{algo-insert-2}
\end{algorithm}

Переполнение буфера возникает примерно каждые $\log\log n$ вставок
и требует $\log \log n$ дополнительных действий на вставку элемента
в \MH[2]. Переполнение
\MH[2] возникает примерно каждые $\log n$ вставок и требует $\log n$
действий на вставку в \MH[1]. Отсюда следует амортизированная оценка
в $O(1)$ сравнений на вставку одного элемента.

Для удаления необходимо, как и в \SCH, вставить \MH[1] и \MH[2] в \HH,
затем просмотреть буфер и вершину \HH и поступить согласно
алгоритму~\ref{algo-extractmin-simple}.
