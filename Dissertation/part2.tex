\chapter{Улучшение асимптотики} \label{chapt-ch}

В предыдущей главе была описана структура очереди с приоритетом, позволяющая
добавлять элемент за $O(1)$ сравнений и удалять минимум за $O(\log k + \log n)$
сравнений, где $n$ "--- количество добавлений, $k$ "--- количество удалений
к моменту вызова операции удаления. Обе оценки выполняются в худшем случае.

В этой главе вторая оценка будет улучшена.  Будет описана структура данных \CH,
позволяющая улучшить асимптотику удаления до $(O\log k + \log \log \dots \log n)$
для любого наперёд заданного константного числа итераций логарифма, сохранив при
этом константную сложность добавления. Кроме того, (напрямую из предыдущей)
будут получены очереди с приоритетом со сложностью вставки и удаления,
соответственно, ($O(r)$,~$O(\log^{(r)} n + r (\log k + \log r))$) для
любого $r > 0$ и ($O(\log^* n)$,~$O(\log^* n(\log k + \log \log^* n))$).

Посмотрим на операцию \textbf{extractMin} в структуре данных, описанной в предыдущей
главе. Видно, что узкое место в асимптотике "--- просмотр буфера и достраивание
кучи $T$, если приходится экстренно завершать балансировку на первой стадии:
эта часть работает за $O(\log n)$, в то время как остальные за $O(\log k)$.
Значит, нужно избавиться от полного просмотра буфера при удалении.

Вообще говоря, просматривать весь буфер не нужно, требуется только уметь быстро
находить минимум. Для этого можно рекурсивно построить такую же структуру данных
размера $\log n$ на элементах буфера и вместо просмотра буфера делать запрос к ней.
Во внутренней структуре, в свою очередь, будет свой буфер (размера $\log \log n$).
Появятся две промежуточных кучи MH: одна во внутренней структуре, <<куча куч>>,
вторая "--- во внешней, <<куча куч куч>>. Head Heap сохранится в единственном
экземпляре и будет использоваться как при внутренней балансировке, так и при внешней.

Основная идея \CH заключается в том, чтобы рекурсивно строить аналогичную
структуру на буфере предыдущего уровня до тех пор, пока буфер не станет достаточно
маленького размера. В зависимости от глубины вложенности может достигаться
разная комбинация асимптотик времени добавления и извлечения, как было сказано
в начале этой главы.

В первой части будет описана \CH глубины вложенности 2 с амортизированными оценками
временной сложности. В следующих частях этой главы будет более детально рассмотрена
произвольная глубина вложенности, произведена деамортизация и доказана асимптотика
и корректность.

\section{\CH вложенности 2}
Описываемая в этом разделе структура "--- надстройка над \SCH, в которой
для уменьшения размера буфера добавляется ещё один уровень буферизации.
Это позволяет уменьшить время добавления до $O(\log k + \log \log n)$.

\CH вложенности 2 (или \CH[2]) состоит из следующих частей:

\begin{enumerate}
\item Буфер, куда изначально попадают элементы. Его размер растёт при добавлении
    элементов и поддерживается примерно равным $\log \log n$.
\item Промежуточная куча \MH[1]. Сюда попадают кучи, построенные на элементах
    буфера. Размер \MH[1] не превосходит $O(\log n)$.
\item Промежуточная куча \MH[2], <<куча куч куч>>. Когда \MH[1] становится
    слишком большого размера, её нужно добавить в \MH[2].
\item Конечная куча \HH, используемая так же, как и в \SCH.
\end{enumerate}

Алгоритм~\ref{algo-insert-2} более подробно иллюстрирует вставку элемента.
В данном случае оценка $O(1)$ на вставку амортизированная, деамортизация будет
проведена позже.

\begin{algorithm}[h]
 \KwData{$x \in \myX$}
 добавить $x$ в конец буфера\;
 \If{размер буфера $> \log_2 \log_2 n$}{
     создать двоичную кучу $T$ из элементов буфера\;
     очистить буфер\;
     добавить кучу $T$ в \MH[1]\;
 }
 \If{размер \MH[1] $> \log_2 \log_2 n$}{
     добавить \MH[1] в \MH[2]\;
     очистить \MH[1]\;
 }
 \caption{Операция \textbf{insert} в \CH[2]}
 \label{algo-insert-2}
\end{algorithm}

Переполнение буфера возникает примерно каждые $\log\log n$ вставок
и требует $\log \log n$ дополнительных действий на вставку элемента
в \MH[1]. Переполнение
\MH[1] возникает примерно каждые $\log n$ вставок и требует $\log n$
действий на вставку в \MH[2]. Отсюда следует амортизированная оценка
в $O(1)$ сравнений на вставку одного элемента.

Для удаления необходимо, как и в \SCH, вставить \MH[2] и \MH[1] в \HH,
затем просмотреть буфер и вершину \HH и поступить согласно
алгоритму~\ref{algo-extractmin-simple}.

Описание \CH[2] приведено только для упрощения понимания того, как
устроена многоуровневая структура. В дальнейшем все описания и доказательства
будут приведены только для общего случая, т.~е.~\CH[r].

\section{\CH произвольной вложенности}
По аналогии с \CH[2] можно определить \CH[r] для произвольного натурального $r$.  
\CH[r] состоит из следующих частей:

\begin{enumerate}
\item Буфер, куда изначально попадают элементы. Его размер растёт при добавлении
    элементов и поддерживается примерно равным $\log^{(r)} n$.
\item Промежуточные кучи \MH[1], \dots, \MH[r]. Размер кучи \MH[t] не превосходит
    $\log^{(r-t)} n$, $1 \leq t < r$. Размер кучи \MH[r] не превосходит $n$.
\item Конечная куча \HH, используемая так же, как и в \SCH.
\end{enumerate}

Вставка происходит по аналогии с \SCH и \CH[2]: элемент добавляется в буфер,
при переполнении буфера на нём строится двоичная куча и вставляется в \MH[1],
при переполнении кучи \MH[1] она вставляется в \MH[2] и т.~д., то есть
когда очередная промежуточная куча (кроме максимальной) достигает своего предельного
размера, она вставляется в промежуточную кучу следующего уровня.
На каждом уровне при переполнении суммарно выполняется $O(n)$ действий,
поэтому суммарное амортизированное время вставки~--- $O(r)$.

Удаление минимума происходит по аналогии с предыдущими описанными структурами.
\MH[1], \dots, \MH[r] добавляются в \HH, затем минимум извлекается из \HH
или из буфера. Можно показать, что размер \HH не превосходит
$O(k \cdot r)$, поэтому на одно удаление требуется $O(\log k + \log r + \log^{(r)} n)$
сравнений. Обе заявленные асимптотики будут доказаны далее.

\section{\CH неограниченной вложенности}

В предыдущей секции количество промежуточных куч (параметр $r$) было фиксированным.
Размер каждой следующей кучи поддерживался равным экспоненте от размера
предыдущей. Можно сохранить это свойство, при этом не ограничивая количество куч.
Таким образом, \MH[1] переполняется при размере 2, \MH[2]~--- при размере $2^2 = 4$,
\MH[3]~--- при размере $2^{2^2} = 16$, \dots, \MH[t]~--- при размере ${}^{t}2$,
где ${}^{a}n$~--- операция \emph{тетрации}.

\begin{definition}
Для любого положительного вещественного $a > 0$ и неотрицательного целого $n \geq 0$,
тетрацию ${}^na$ можно определить реккурентно:
\begin{enumerate}
\item ${}^0a$ = 1,
\item ${}^na = a^{({}^{n-1}a)}$, $n > 0$.
\end{enumerate}
Иными словами, тетрация~--- это результат вычисления <<степенной башни>> высоты $n$
из чисел $a$~(\cite{tetration}).
\end{definition}

Одновременно можно избавиться от буфера и добавлять элементы сразу в \MH[1], поскольку
добавление в кучу размера $\leq 2$ требует $O(1)$ сравнений. В остальном
вставка элемента и извлечение минимума абсолютно аналогичны рассмотренным ранее структурам.

\section{Деамортизация}
Как и в случае с \SCH, деамортизация нужна только для процесса балансировки.
Здесь способ, рассмотренный в разделе~\ref{deamort-simple}, будет применён для
каждого уровня в отдельности. Вначале мы рассмотрим деамортизацию \CH[r],
затем описанный способ будет адаптирован для \CH[*].

\subsection{Деамортизация \CH[r]}
Сделаем все \MH[t] кучами с версией (см. параграф~\ref{heap-with-versions}).
При вставке возможны два вида переполнений:
\begin{enumerate}
\item Переполнение буфера. При таком переполнении нужно построить кучу на элементах
    буфера, а затем вставить её в \MH[1]. Назовём это \emph{балансировкой нулевого уровня}.
\item Переполнение одной из куч \MH[1], \dots, \MH[r-1]. При таком переполнении
    нужно только вставить переполнившуюся куча в промежуточную кучу следующего
    уровня. Назовём процесс вставки \MH[t] в \MH[t+1] \emph{балансировкой $t$-го уровня}.
\end{enumerate}

В любой момент времени на каждом уровне может происходить балансировка. При выполнении
операции \textbf{insert} надо провести несколько операций по балансировке на каждом из них.
Эти балансировки независимы: если какая-то куча \MH[t] переполнилась и вставляется
в \MH[t+1], её состояние <<замораживается>>, и в неё саму больше не будет ничего вставлено.
Если в момент переполнения \MH[t] в неё производится отложенная вставка,
то вставку нужно завершить и сделать вставляемый элемент единственным
элементом новой \MH[t].

Далее будет показано, что балансировка $t$-го уровня может выполняться
в течение $\log^{(r-t)}n$ вставок и требует $O(\log^{(r-t)}n)$ времени,
значит, деамортизацию на каждом уровне
можно выполнять за $O(1)$ сравнений при каждом вызове \textbf{insert}. Так можно
достичь оценки в $O(r)$ сравнений на операцию добавления в худшем случае.

Для того, чтобы выполнить операцию \textbf{extractMin}, нужно экстренно завершить
балансировку на каждом уровне, затем, как обычно, добавить \MH[1], \dots, \MH[r] в \HH
и извлечь минимум из \HH или из буфера. Завершение балансировки на первом уровне
требует достраивания кучи на элементах буфера и отмены вставки в \MH[1], для этого
необходимо $O(\log^{(r)} n)$ сравнений. Завершение балансировки на уровнях после
первого включает в себя только отмену вставки и производится за $O(1)$ (если быть
точным, за 0 сравнений).

\subsection{Деамортизация \CH[*]}
Деамортизация \CH[*] происходит абсолютно аналогично. Различие лишь в отсутствии
нулевого уровня  балансировки: в \CH[*], в отличие от \CH[r], нет буфера,
поэтому завершение балансировки происходит за $O(1)$ на каждом уровне.

\section{Алгоритм}
За $T_0$, \dots, $T_{r}$, \dots обозначены отложенно вставляемые кучи.
$T_t$ вставляется в \MH[t+1]. Во время первой стадии балансировки нулевого
уровня $T_0$ также обозначает кучу в процессе построения.

Инициализация и операции для \CH[r] показаны в
алгоритмах~\labelcref{alg:init-r,alg:insert-r,alg:extractmin-r}, для \CH[*]~---
в алгоритмах~\labelcref{alg:init-*,alg:insert-*,alg:extractmin-*}.
\input{Dissertation/algorithm-fast}

\newpage
\section{Доказательства} \label{sec:proof}
\input{Dissertation/proof}
