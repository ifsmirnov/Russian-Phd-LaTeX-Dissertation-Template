\chapter{Улучшение асимптотики} \label{chapt-ch}

В предыдущей главе была описана структура очереди с приоритетом, позволяющая
добавлять элемент за $O(1)$ сравнений и удалять минимум за $O(\log k + \log n)$
сравнений, где $n$ "--- количество добавлений, $k$ "--- количество удалений
к моменту вызова операции удаления. Обе оценки выполняются в худшем случае.

В этой главе вторая оценка будет улучшена.  Будет описана структура данных \CH,
позволяющая улучшить асимптотику удаления до $(O\log k + \log \log \dots \log n)$
для любого наперёд заданного константного числа итераций логарифма, сохранив при
этом константную сложность добавления. Кроме того, (напрямую из предыдущей)
будут получены очереди с приоритетом со сложностью вставки и удаления,
соответственно, ($O(t)$,~$O(t \cdot \log k + \log ^{(t)} n)$) и
($O(\log^* n)$,~$O(\log^* n \cdot \log k)$).

\todo{Поменять t на r и добавить хвостик к заявленной асимптотике}


\section*{Анонс}

Посмотрим на операцию \textbf{extractMin} в структуре данных, описанной в предыдущей
главе. Видно, что узкое место в асимптотике "--- просмотр буфера и достраивание
кучи $T$, если приходится экстренно завершать балансировку на первой стадии:
эта часть работает за $O(\log n)$, в то время как остальные за $O(\log k)$.
Значит, нужно избавиться от полного просмотра буфера при удалении.

Вообще говоря, просматривать весь буфер не нужно, требуется только уметь быстро
находить минимум. Для этого можно рекурсивно построить такую же структуру данных
размера $\log n$ на элементах буфера и вместо просмотра буфера делать запрос к ней.
Во внутренней структуре, в свою очередь, будет свой буфер (размера $\log \log n$).
Появятся две промежуточных кучи MH: одна во внутренней структуре, <<куча куч>>,
вторая "--- во внешней, <<куча куч куч>>. Head Heap сохранится в единственном
экземпляре и будет использоваться как при внутренней балансировке, так и при внешней.

Основная идея \CH заключается в том, чтобы рекурсивно строить аналогичную
структуру на буфере предыдущего уровня до тех пор, пока буфер не станет достаточно
маленького размера. В зависимости от глубины вложенности может достигаться
разная комбинация асимптотик времени добавления и извлечения, как было сказано
в начале этой главы.

В первой части будет описана \CH глубины вложенности 2 с амортизированными оценками
временной сложности. В следующих частях этой главы будет более детально рассмотрена
произвольная глубина вложенности, произведена деамортизация и доказана асимптотика
и корректность.

\section{\CH вложенности 2}
Описываемая в этом разделе структура "--- надстройка над \SCH, в которой
для уменьшения размера буфера добавляется ещё один уровень буферизации.
Это позволяет уменьшить время добавления до $O(\log k + \log \log n)$.

\CH вложенности 2 (или \CH[2]) состоит из следующих частей:

\begin{enumerate}
\item Буфер, куда изначально попадают элементы. Его размер растёт при добавлении
    элементов и поддерживается примерно равным $\log \log n$.
\item Промежуточная куча \MH[1]. Сюда попадают кучи, построенные на элементах
    буфера. Размер \MH[1] не превосходит $O(\log n)$.
\item Промежуточная куча \MH[2], <<куча куч куч>>. Когда \MH[1] становится
    слишком большого размера, её нужно добавить в \MH[2].
\item Конечная куча \HH, используемая так же, как и в \SCH.
\end{enumerate}

Алгоритм~\ref{algo-insert-2} более подробно иллюстрирует вставку элемента.
В данном случае оценка $O(1)$ на вставку амортизированная, деамортизация будет
проведена позже.

\begin{algorithm}[h]
 \KwData{$x \in \myX$}
 добавить $x$ в конец буфера\;
 \If{размер буфера $> \log_2 \log_2 n$}{
     создать двоичную кучу $T$ из элементов буфера\;
     очистить буфер\;
     добавить кучу $T$ в \MH[1]\;
 }
 \If{размер \MH[1] $> \log_2 \log_2 n$}{
     добавить \MH[1] в \MH[2]\;
     очистить \MH[1]\;
 }
 \caption{Операция \textbf{insert} в \CH[2]}
 \label{algo-insert-2}
\end{algorithm}

Переполнение буфера возникает примерно каждые $\log\log n$ вставок
и требует $\log \log n$ дополнительных действий на вставку элемента
в \MH[1]. Переполнение
\MH[1] возникает примерно каждые $\log n$ вставок и требует $\log n$
действий на вставку в \MH[2]. Отсюда следует амортизированная оценка
в $O(1)$ сравнений на вставку одного элемента.

Для удаления необходимо, как и в \SCH, вставить \MH[2] и \MH[1] в \HH,
затем просмотреть буфер и вершину \HH и поступить согласно
алгоритму~\ref{algo-extractmin-simple}.

\todo{вставить сюда какую-нибудь картинку про то, что происходит}

\section{\CH произвольной вложенности}
По аналогии с \CH[2] можно определить \CH[r] для произвольного натурального $r$.  
\CH[r] состоит из следующих частей:

\begin{enumerate}
\item Буфер, куда изначально попадают элементы. Его размер растёт при добавлении
    элементов и поддерживается примерно равным $\log^{(r)} n$.
\item Промежуточные кучи \MH[1], \dots, \MH[r]. Размер кучи \MH[t] не превосходит
    $\log^{(r-t)} n$, $1 \leq t < r$. Размер кучи \MH[r] не превосходит $n$.
\item Конечная куча \HH, используемая так же, как и в \SCH.
\end{enumerate}

Вставка происходит по аналогии с \SCH и \CH[2]: элемент добавляется в буфер,
при переполнении буфера на нём строится двоичная куча и вставляется в \MH[1],
при переполнении кучи \MH[1] она вставляется в \MH[2] и т.~д., то есть
когда очередная промежуточная куча (кроме максимальной) достигает своего предельного
размера, она вставляется в промежуточную кучу следующего уровня.
На каждом уровне при переполнении суммарно выполняется $O(n)$ действий,
поэтому суммарное амортизированное время вставки~--- $O(r)$.

Удаление минимума происходит по аналогии с предыдущими описанными структурами.
\MH[1], \dots, \MH[r] добавляются в \HH, затем минимум извлекается из \HH
или из буфера. Можно показать, что размер \HH не превосходит
$O(k \cdot r)$, поэтому на одно удаление требуется $O(\log k + \log r + \log^{(r)} n)$
сравнений. Обе заявленные асимптотики будут доказаны далее.

\section{\CH неограниченной вложенности}

В предыдущей секции количество промежуточных куч (параметр $r$) было фиксированным.
Размер каждой следующей кучи поддерживался равным экспоненте от размера
предыдущей. Можно сохранить это свойство, при этом не ограничивая количество куч.
Таким образом, \MH[1] переполняется при размере 2, \MH[2]~--- при размере $2^2 = 4$,
\MH[3]~--- при размере $2^{2^2} = 16$, \dots, \MH[t]~--- при размере ${}^{t}2$,
где ${}^{a}n$~--- операция \emph{тетрации}.

\begin{definition}
Для любого положительного вещественного $a > 0$ и неотрицательного целого $n \geq 0$,
тетрацию ${}^na$ можно определить реккурентно:
\begin{enumerate}
\item ${}^0a$ = 1,
\item ${}^na = a^{({}^{n-1}a)}$, $n > 0$.
\end{enumerate}
Иными словами, тетрация~--- это результат вычисления <<степенной башни>> высоты из $n$
чисел $a$~(\cite{tetration}).
\end{definition}

Одновременно можно избавиться от буфера и добавлять элементы сразу в \MH[1], поскольку
добавление в кучу размера $\leq 2$ требует $O(1)$ сравнений.
