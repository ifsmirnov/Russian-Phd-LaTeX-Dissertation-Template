% ГОСТ Р 7.0.11-2011, Приложение Б, Книги
@BOOK{Cormen,
  author = {Кормен, Т. and Лейзерсон, Ч. and Ривест, Р. and Штайн, К.},
  title = {Алгоритмы: построение и анализ = Introduction to Algorithms},
  editor = {И. В. Красикова},
  address = {М.},
  publisher = {Вильямс},
  edition   = {2},
  year = {2005},
  numpages = {1296},
  language = {russian}
}

@ONLINE{tetration,
    title = {Тетрация~--- Википедия},
    url = {https://ru.wikipedia.org/wiki/Тетрация},
    urldate = {2016-06-23}
}

@ONLINE{partial-sort,
    title = {Partial Sorting~--- Wikipedia},
    url = {https://en.wikipedia.org/wiki/Partial_sorting},
    urldate = {2016-06-26}
}
@inproceedings{opt-inc-sort,
    author = {Paredes, Rodrigo and Navarro, Gonzalo},
    title = {Optimal Incremental Sorting},
    booktitle = {Proceedings of the Meeting on Algorithm Engineering \& Expermiments},
    year = {2006},
    location = {Miami, Florida},
    pages = {171--182},
    numpages = {12},
    url = {http://dl.acm.org/citation.cfm?id=2791171.2791187},
    acmid = {2791187},
    publisher = {Society for Industrial and Applied Mathematics},
    address = {Philadelphia, PA, USA},
} 

@Article{quick-heap,
author="Navarro, Gonzalo and Paredes, Rodrigo",
title="On Sorting, Heaps, and Minimum Spanning Trees",
journal="Algorithmica",
year="2010",
volume="57",
number="4",
pages="585--620",
abstract="Let A be a set of size m. Obtaining the first k≤m elements of A in ascending order can be done in optimal O(m+klog{\thinspace}k) time. We present Incremental Quicksort (IQS), an algorithm (online on k) which incrementally gives the next smallest element of the set, so that the first k elements are obtained in optimal expected time for any k. Based on IQS, we present the Quickheap (QH), a simple and efficient priority queue for main and secondary memory. Quickheaps are comparable with classical binary heaps in simplicity, yet are more cache-friendly. This makes them an excellent alternative for a secondary memory implementation. We show that the expected amortized CPU cost per operation over a Quickheap of m elements is O(log{\thinspace}m), and this translates into O((1/B)log{\thinspace}(m/M)) I/O cost with main memory size M and block size B, in a cache-oblivious fashion. As a direct application, we use our techniques to implement classical Minimum Spanning Tree (MST) algorithms. We use IQS to implement Kruskal's MST algorithm and QHs to implement Prim's. Experimental results show that IQS, QHs, external QHs, and our Kruskal's and Prim's MST variants are competitive, and in many cases better in practice than current state-of-the-art alternative (and much more sophisticated) implementations.",
issn="1432-0541",
doi="10.1007/s00453-010-9400-6",
url="http://dx.doi.org/10.1007/s00453-010-9400-6"
}




% Examples from https://verbosus.com/bibtex-style-examples.html
% @BOOK{Book,
%   author    = {Peter Babington}, 
%   title     = {The title of the work},
%   publisher = {The name of the publisher},
%   year      = {1993},
%   volume    = {4},
%   series    = {10},
%   address   = {The address},
%   edition   = {3},
%   month     = {7},
%   note      = {An optional note},
%   isbn      = {3257227892},
%   language  = {english}
% }
% @ARTICLE{Article,
%   author   = {Peter Adams},
%   title    = {The title of the work},
%   journal  = {The name of the journal},
%   year     = {1993},
%   number   = {2},
%   pages    = {201-213},
%   month    = {7},
%   note     = {An optional note},
%   volume   = {4},
%   language = {english}
% }
% 
